<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Dimensionality Quest — 1D/2D/3D</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #f6f7ff;
    --ink: #111827;
    --muted: #6b7280;
    --card: #ffffff;
    --accent: #6366f1;
  }
  html, body {
    margin: 0;
    padding: 0;
    background: var(--bg);
    color: var(--ink);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  }
  .wrap {
    max-width: 1050px;
    margin: 18px auto;
    padding: 0 12px;
  }
  h1 { font-size: 1.6rem; margin: 0 0 4px; }
  p.lead { margin: 0 0 12px; color: var(--muted); }
  .bar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 12px;
  }
  .seg {
    background: #eef2ff;
    border-radius: 999px;
    padding: 4px;
    display: inline-flex;
    gap: 4px;
  }
  .seg button {
    border: 0;
    background: transparent;
    padding: 8px 12px;
    border-radius: 999px;
    color: #374151;
    cursor: pointer;
  }
  .seg button.active {
    background: #ffffff;
    box-shadow: 0 1px 2px rgba(0,0,0,.08);
    color: #111827;
    font-weight: 600;
  }
  .btn {
    border: 0;
    background: var(--ink);
    color: white;
    padding: 8px 12px;
    border-radius: 12px;
    cursor: pointer;
  }
  .btn.alt {
    background: #4b5563;
  }
  .small { color: var(--muted); font-size: 0.9rem; }
  .card {
    background: var(--card);
    border-radius: 16px;
    box-shadow: 0 10px 24px rgba(0,0,0,.06);
    padding: 14px;
  }
  .titlebar {
    background: #111827;
    color: #ffffff;
    padding: 8px 12px;
    border-radius: 12px;
    font-weight: 600;
    font-size: 0.92rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .row {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
  }
  @media (min-width: 900px) {
    .row { grid-template-columns: 1fr 1fr; }
  }
  .kv {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .slider-container {
    flex: 1 1 auto;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .slider {
    width: 160px;
  }
  canvas {
    width: 100%;
    height: auto;
    border-radius: 12px;
    border: 1px solid #e5e7eb;
    display: block;
    background: #ffffff;
  }
  .hint {
    font-size: 0.8rem;
    color: var(--muted);
    margin-top: 6px;
  }
  .hidden { display: none !important; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Dimensionality Quest</h1>
  <p class="lead">We have hidden <b>5D</b> treasure. Put on different "magic glasses" to see it in <b>1D</b>, <b>2D</b> or <b>3D</b> — without losing patterns!</p>

  <div class="bar">
    <div class="seg" id="levelSeg"></div>
    <div class="seg" id="dimSeg"></div>
    <button class="btn" id="shuffleBtn">Shuffle dataset</button>
    <div style="width:1px;height:28px;background:#d1d5db;"></div>
    <div class="seg" id="methodSeg"></div>
    <div class="kv" id="neighborTools" style="display:none">
      <label class="small">k-NN <input type="range" id="knnSlider" min="2" max="16" value="6" style="width: 100px"></label>
      <button class="btn" id="autoBtn">Auto</button>
      <button class="btn alt" id="stepBtn">Step</button>
      <label class="small"><input type="checkbox" id="edgesChk"> Show edges</label>
      <span class="small">Iterations: <b id="iterLabel">0</b></span>
    </div>
    <div class="kv" id="rot3dTools" style="display:none">
      <label class="small"><input type="checkbox" id="autoRotChk" checked> Auto-rotate 3D</label>
    </div>
  </div>

  <div class="card">
    <div class="titlebar">
      <div id="titleLeft">Dimensionality Quest — Manual (2D)</div>
      <div id="titleRight">Score: 0.00 (goal 0.60)</div>
    </div>
    <canvas id="plot" width="960" height="600"></canvas>
    <div class="hint">Tip: <b>Click</b> to add a point (inherits nearest color). <b>Shift+Click</b> to remove nearest. Switch methods to watch the cloud morph.</div>
  </div>

  <div class="row" id="manualRow" style="margin-top: 10px;">
    <div class="card">
      <div style="font-weight: 600; margin-bottom: 6px;">Choose your own axes (weights for 5D → 1D/2D/3D)</div>
      <div id="weights"></div>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button class="btn alt" id="resetWeightsBtn">Reset</button>
        <button class="btn" id="hintPcaBtn">Use PCA as a hint</button>
      </div>
    </div>
    <div class="card">
      <div style="font-weight: 600; margin-bottom: 6px;">Which dimensions matter? (spread per feature)</div>
      <div id="spreads"></div>
      <div class="hint">PCA automatically finds directions with big spread.</div>
    </div>
  </div>

  <div class="row" style="margin-top: 10px;">
    <div class="card">
      <div style="font-weight: 600; margin-bottom: 6px;">Goal</div>
      <div>Reach a <b id="goalLabel">score ≥ 0.60</b> by separating colors after projection. Score compares how far color centers are vs. how wiggly each group is.</div>
      <div class="hint" style="margin-top: 6px;">Level 1 (Blobs) is linear-friendly — PCA & Manual do great. Level 2 (Twisty Moons) is curvy — try Neighbor Map.</div>
    </div>
    <div class="card">
      <div style="font-weight: 600; margin-bottom: 6px;">Mini challenges</div>
      <ol style="margin: 0 0 0 20px;">
        <li>Pick <b>2D PCA</b>. Does it beat random? Then mimic it with Manual sliders.</li>
        <li>Try <b>1D</b>: can you keep colors apart on a line?</li>
        <li>Switch to <b>3D</b> and rotate — does 3D reveal patterns hidden in 2D?</li>
        <li>Level 2 + <b>Neighbor Map</b>: turn on edges, Step/Auto to untangle the moons.</li>
      </ol>
    </div>
  </div>
</div>

<script>
(function(){
  // ======== Globals and State ========
  const COLORS = ["#ef4444","#10b981","#3b82f6","#f59e0b","#8b5cf6","#ec4899","#14b8a6","#eab308"];
  // Data and configuration
  let level = 'blobs'; // 'blobs' | 'moons'
  let D = 2;          // 1 | 2 | 3
  let method = 'manual'; // 'manual' | 'pca' | 'rand' | 'neighbor'
  let seed = 1;
  let points = [];   // { v: [5], label: number }
  let kClasses = 3;  // number of classes
  let target = 0.60; // goal score
  // Projection weights (for manual)
  let weights = [ [1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0] ];
  // Current projected positions (pos[i] is an array of length D)
  let pos = [];
  let projected = [];
  // Neighbor map state
  let nmAdj = [];
  let autoIter = false;
  let iterCount = 0;
  let showEdges = false;
  // 3D rotation state
  let yaw = 0.6;
  let pitch = 0.3;
  let autoRotate3D = true;
  let neighborInterval = null;

  // ======== DOM Elements ========
  const levelSeg = document.getElementById('levelSeg');
  const dimSeg   = document.getElementById('dimSeg');
  const methodSeg= document.getElementById('methodSeg');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const neighborTools = document.getElementById('neighborTools');
  const knnSlider = document.getElementById('knnSlider');
  const autoBtn = document.getElementById('autoBtn');
  const stepBtn = document.getElementById('stepBtn');
  const edgesChk = document.getElementById('edgesChk');
  const iterLabel = document.getElementById('iterLabel');
  const rot3dTools= document.getElementById('rot3dTools');
  const autoRotChk = document.getElementById('autoRotChk');
  const manualRow = document.getElementById('manualRow');
  const weightsDiv = document.getElementById('weights');
  const spreadsDiv = document.getElementById('spreads');
  const titleLeft = document.getElementById('titleLeft');
  const titleRight = document.getElementById('titleRight');
  const goalLabel = document.getElementById('goalLabel');
  const hintPcaBtn = document.getElementById('hintPcaBtn');
  const resetWeightsBtn = document.getElementById('resetWeightsBtn');
  const canvas = document.getElementById('plot');
  const ctx = canvas.getContext('2d');

  // ======== Utility Functions ========
  function rng(seedVal) {
    let s = seedVal >>> 0;
    return function() {
      s = (1664525 * s + 1013904223) >>> 0;
      return (s >>> 0) / 4294967296;
    };
  }
  function dot(a,b) { let s=0; for(let i=0;i<a.length;i++) s += a[i]*b[i]; return s; }
  function norm(v) { return Math.sqrt(Math.max(1e-12, v.reduce((s,x)=> s + x*x, 0))); }
  function center(X) {
    const d = X[0].length;
    const mu = new Array(d).fill(0);
    X.forEach(v => v.forEach((val,j) => mu[j] += val));
    mu.forEach((_,j) => mu[j] /= X.length);
    const X0 = X.map(v => v.map((val,j) => val - mu[j]));
    return { X0, mu };
  }
  function powerIterTopK(X, K) {
    const d = X[0].length;
    const { X0 } = center(X);
    function covAx(x) {
      const n = X0.length;
      const tmp = new Array(n);
      for(let i=0;i<n;i++) tmp[i] = dot(X0[i], x);
      const y = new Array(d).fill(0);
      for(let j=0;j<d;j++) {
        let s = 0;
        for(let i=0;i<n;i++) s += X0[i][j] * tmp[i];
        y[j] = s / n;
      }
      return y;
    }
    function topVec(defls) {
      let x = new Array(d).fill(0).map(() => Math.random() * 2 - 1);
      for(let it=0; it<40; it++) {
        let y = covAx(x);
        if(defls && defls.length) {
          for(const {vec,val} of defls) {
            const qt = dot(vec, x);
            for(let j=0;j<d;j++) y[j] -= vec[j] * qt * val;
          }
        }
        const n = norm(y);
        x = y.map(v => v / n);
      }
      const y = covAx(x);
      const val = dot(x,y);
      return { vec: x, val };
    }
    const out=[];
    const defls=[];
    for(let k=0;k<K;k++) {
      const t = topVec(defls);
      out.push(t.vec);
      defls.push(t);
    }
    return out;
  }
  function randomOrtho(d, K, bump=0) {
    const r = rng(seed + 123 + bump);
    function randVec() {
      const v = new Array(d).fill(0).map(() => r() * 2 - 1);
      const n = norm(v);
      return v.map(x => x / n);
    }
    const basis = [];
    for(let k=0;k<K;k++) {
      let v = randVec();
      for(let i=0;i<basis.length;i++) {
        const proj = dot(basis[i], v);
        v = v.map((x,j) => x - basis[i][j] * proj);
      }
      const nv = norm(v);
      basis.push(v.map(x => x / nv));
    }
    return basis;
  }
  function projectND(X, basis) {
    const { X0 } = center(X);
    const U = basis.map(b => b.map(x => x / norm(b)));
    return X0.map(v => U.map(u => dot(v,u)));
  }

  // Dataset generators
  function genBlobs(n=240, k=3) {
    const r = rng(seed);
    const means = [
      [2.2,0.5,0.0,-1.5,0.3],
      [-1.0,2.0,0.5,0.8,-0.7],
      [0.2,-1.3,1.7,0.6,1.2],
      [2.0,1.2,-1.5,0.0,-0.3],
      [-1.8,-0.6,1.0,-1.2,0.9]
    ];
    const pts=[];
    for(let i=0;i<n;i++) {
      const c = i % k;
      const m = means[c];
      const v = m.map(mu => mu + (r()-0.5)*0.9);
      pts.push({ v, label: c });
    }
    return pts;
  }
  function genMoons(n=240) {
    const r = rng(seed);
    const pts = [];
    for(let i=0;i<n/2;i++) {
      const t = Math.PI * (i/(n/2));
      const base = [2*Math.cos(t),1.2*Math.sin(t),0.6*Math.cos(2*t),0.6*Math.sin(2*t),0.3*Math.cos(3*t)];
      const v = base.map((b,j) => b + (r()-0.5)*0.25 * (j<2 ? 1.0 : 0.7));
      pts.push({ v, label: 0 });
    }
    for(let i=0;i<n/2;i++) {
      const t = Math.PI * (i/(n/2));
      const base = [2*Math.cos(t)+1.8,-1.2*Math.sin(t)+0.5,0.6*Math.cos(2*t+0.6),0.6*Math.sin(2*t+0.6),0.3*Math.cos(3*t+0.2)];
      const v = base.map((b,j) => b + (r()-0.5)*0.25 * (j<2 ? 1.0 : 0.7));
      pts.push({ v, label: 1 });
    }
    return pts;
  }

  // Neighbor map helpers
  function knnGraph(X, k=6) {
    const n = X.length;
    const adj = Array.from({length:n}, () => []);
    for(let i=0;i<n;i++) {
      const ds = [];
      for(let j=0;j<n;j++) {
        if(i===j) continue;
        let s=0;
        for(let t=0;t<X[i].length;t++) {
          const u = X[i][t] - X[j][t];
          s += u*u;
        }
          ds.push({ j, d: Math.sqrt(s) });
      }
      ds.sort((a,b) => a.d - b.d);
      adj[i] = ds.slice(0, k).map(e => e.j);
    }
    return adj;
  }
  function neighborStepND(posList, adj) {
    const n = posList.length;
    const d = posList[0].length;
    const next = posList.map(p => p.slice());
    const kStiff=0.03, rest=0.7, repel=0.001;
    // Attractive forces (edges)
    for(let i=0;i<n;i++) {
      for(const j of adj[i]) {
        if(j <= i) continue;
        const dx = new Array(d).fill(0);
        let dist2=1e-9;
        for(let t=0;t<d;t++) {
          dx[t] = posList[j][t] - posList[i][t];
          dist2 += dx[t]*dx[t];
        }
        const dist = Math.sqrt(dist2);
        const f = kStiff * (dist - rest);
        for(let t=0;t<d;t++) {
          const comp = f * dx[t] / dist;
          next[i][t] += comp;
          next[j][t] -= comp;
        }
      }
    }
    // Repulsive forces
    for(let i=0;i<n;i++) {
      for(let j=i+1;j<n;j++) {
        const dx = new Array(d).fill(0);
        let d2=1e-9;
        for(let t=0;t<d;t++) {
          dx[t] = next[j][t] - next[i][t];
          d2 += dx[t]*dx[t];
        }
        const f = repel / d2;
        for(let t=0;t<d;t++) {
          const comp = f * dx[t];
          next[i][t] -= comp;
          next[j][t] += comp;
        }
      }
    }
    return next;
  }

  // Scoring function
  function scoreSeparationND(P) {
    if(!P.length) return 0;
    const k = kClasses;
    const groups = Array.from({length:k}, () => ({ sum: Array(D).fill(0), n: 0, idxs: [] }));
    for(let i=0;i<P.length;i++) {
      const c = points[i] ? points[i].label : null;
      const p = P[i];
      if(c != null && groups[c]) {
        for(let dIdx=0; dIdx<D; dIdx++) {
          groups[c].sum[dIdx] += p[dIdx];
        }
        groups[c].n++;
        groups[c].idxs.push(i);
      }
    }
    const mu = new Array(D).fill(0);
    for(const g of groups) {
      for(let dIdx=0; dIdx<D; dIdx++) mu[dIdx] += g.sum[dIdx];
    }
    for(let dIdx=0; dIdx<D; dIdx++) mu[dIdx] /= P.length;
    let SB=0, SW=0;
    for(let c=0;c<k;c++) {
      const g = groups[c];
      if(g && g.n > 0) {
        const mc = g.sum.map(s => s / g.n);
        // between-class scatter
        let diff = 0;
        for(let dIdx=0; dIdx<D; dIdx++) {
          const u = mc[dIdx] - mu[dIdx];
          diff += u*u;
        }
        SB += diff;
        // within-class scatter
        for(const idx of g.idxs) {
          const p = P[idx];
          let dsum=0;
          for(let dIdx=0; dIdx<D; dIdx++) {
            const u = p[dIdx] - mc[dIdx];
            dsum += u*u;
          }
          SW += dsum;
        }
      }
    }
    const s = SB / (SW + 1e-6);
    return Math.max(0, Math.min(1, s));
  }

  // ======== UI helpers ========
  function buildSegment(el, opts, active, onPick) {
    el.innerHTML = '';
    opts.forEach(o => {
      const b = document.createElement('button');
      b.textContent = o.label;
      if(o.key === active) b.classList.add('active');
      b.addEventListener('click', () => onPick(o.key));
      el.appendChild(b);
    });
  }
  function buildManualControls() {
    weightsDiv.innerHTML = '';
    // For each feature dimension (5)
    for(let j=0; j<5; j++) {
      const row = document.createElement('div');
      row.className = 'kv';
      // Label
      const label = document.createElement('span');
      label.className = 'small';
      label.style.width = '28px';
      label.textContent = 'd' + (j+1);
      row.appendChild(label);
      // For each output dimension 0..D-1
      for(let dIdx=0; dIdx<D; dIdx++) {
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = -1;
        slider.max = 1;
        slider.step = 0.01;
        slider.value = weights[dIdx][j];
        slider.style.width = '200px';
        const valLabel = document.createElement('span');
        valLabel.className = 'small';
        valLabel.style.width = '42px';
        valLabel.style.textAlign = 'right';
        valLabel.textContent = weights[dIdx][j].toFixed(2);
        slider.addEventListener('input', e => {
          weights[dIdx][j] = parseFloat(e.target.value);
          valLabel.textContent = weights[dIdx][j].toFixed(2);
          if(method === 'manual') {
            computeAndAnimate();
          }
        });
        row.appendChild(slider);
        row.appendChild(valLabel);
        if(dIdx < D-1) {
          const arrow = document.createElement('span');
          arrow.className = 'small';
          arrow.style.width = '14px';
          arrow.style.textAlign = 'center';
          arrow.textContent = '→';
          row.appendChild(arrow);
        }
      }
      weightsDiv.appendChild(row);
    }
  }
  function updateSpreads() {
    spreadsDiv.innerHTML = '';
    if(!points.length) return;
    // Compute standard deviations for each original dimension
    const d = 5;
    const mu = new Array(d).fill(0);
    points.forEach(p => p.v.forEach((val,j) => mu[j] += val));
    mu.forEach((_,j) => mu[j] /= points.length);
    const varr = new Array(d).fill(0);
    points.forEach(p => p.v.forEach((val,j) => {
      const diff = val - mu[j];
      varr[j] += diff * diff;
    }));
    varr.forEach((_,j) => varr[j] = Math.sqrt(varr[j] / Math.max(1, points.length - 1)));
    // Build bars
    for(let j=0;j<5;j++) {
      const row = document.createElement('div');
      row.className = 'kv';
      const lab = document.createElement('span');
      lab.className = 'small';
      lab.style.width = '28px';
      lab.textContent = 'd' + (j+1);
      const barBg = document.createElement('div');
      barBg.style.background = '#f3f4f6';
      barBg.style.borderRadius = '999px';
      barBg.style.overflow = 'hidden';
      barBg.style.width = '260px';
      barBg.style.height = '8px';
      const bar = document.createElement('div');
      const widthPct = Math.min(100, varr[j] * 35);
      // Use a string for CSS custom property; otherwise JavaScript will treat it as undefined
      bar.style.background = 'var(--accent)';
      bar.style.height = '8px';
      bar.style.width = widthPct + '%';
      barBg.appendChild(bar);
      const val = document.createElement('span');
      val.className = 'small';
      val.style.width = '42px';
      val.style.textAlign = 'right';
      val.textContent = varr[j].toFixed(2);
      row.appendChild(lab);
      row.appendChild(barBg);
      row.appendChild(val);
      spreadsDiv.appendChild(row);
    }
  }
  function refreshTitles(score) {
    const mname = method === 'manual' ? 'Manual' : method === 'pca' ? 'PCA' : method === 'rand' ? 'Random' : 'Neighbor Map';
    titleLeft.textContent = `Dimensionality Quest — ${mname} (${D}D)`;
    titleRight.textContent = `Score: ${score.toFixed(2)} (goal ${target.toFixed(2)})`;
    goalLabel.textContent = `score ≥ ${target.toFixed(2)}`;
  }

  // ======== Data and Projection ========
  function loadDataset() {
    if(level === 'blobs') {
      kClasses = 3;
      target = 0.60;
      points = genBlobs(240, 3);
    } else {
      kClasses = 2;
      target = 0.55;
      points = genMoons(240);
    }
  }
  function currentBasis() {
    if(method === 'manual') {
      return weights.slice(0, D).map(w => w.slice());
    }
    if(method === 'pca') {
      return powerIterTopK(points.map(p => p.v), D);
    }
    if(method === 'rand') {
      return randomOrtho(5, D, 77);
    }
    // for neighbor (initial projection)
    return powerIterTopK(points.map(p => p.v), D);
  }
  function computeProjection() {
    const X = points.map(p => p.v);
    if(!X.length) return [];
    return projectND(X, currentBasis());
  }
  function computeAndAnimate() {
    projected = computeProjection();
    pos = projected.map(p => p.slice());
    if(method === 'neighbor') {
      nmAdj = knnGraph(points.map(p => p.v), parseInt(knnSlider.value, 10));
      iterCount = 0;
      iterLabel.textContent = '0';
    }
    updateSpreads();
    buildManualControls();
  }
  function shuffleData() {
    seed++;
    loadDataset();
    computeAndAnimate();
  }

  // ======== Drawing ========
  function draw() {
    // Clear canvas
    ctx.fillStyle = '#f5f7ff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // Draw grid
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;
    for(let x=40; x<960; x+=40) {
      const xx = x * (canvas.width/960);
      ctx.beginPath();
      ctx.moveTo(xx, 0);
      ctx.lineTo(xx, canvas.height);
      ctx.stroke();
    }
    for(let y=40; y<600; y+=40) {
      const yy = y * (canvas.height/600);
      ctx.beginPath();
      ctx.moveTo(0, yy);
      ctx.lineTo(canvas.width, yy);
      ctx.stroke();
    }

    // Auto neighbor iteration if needed
    if(autoIter && method === 'neighbor') {
      pos = neighborStepND(pos, nmAdj);
      iterCount++;
      iterLabel.textContent = String(iterCount);
    }
    // 3D rotation update
    if(D === 3 && autoRotate3D) {
      yaw += 0.01;
    }
    // Compute screen coordinates
    let pts2 = [];
    if(D === 1) {
      if(!pos.length) return;
      let min=Infinity,max=-Infinity;
      pos.forEach(p => { if(p[0] < min) min = p[0]; if(p[0] > max) max = p[0]; });
      const pad = 40;
      const S = (canvas.width - 2*pad) / Math.max(1e-6, max - min);
      const tx = (canvas.width - S * (max + min)) / 2;
      const midY = canvas.height * 0.55;
      for(let i=0;i<pos.length;i++) {
        const jitter = ((points[i].label * 7) % 5) - 2;
        pts2.push({ x: tx + S * pos[i][0], y: midY + jitter });
      }
    } else if(D === 2) {
      if(!pos.length) return;
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
      pos.forEach(p => {
        if(p[0] < minX) minX = p[0];
        if(p[0] > maxX) maxX = p[0];
        if(p[1] < minY) minY = p[1];
        if(p[1] > maxY) maxY = p[1];
      });
      const pad=30;
      const sx = (canvas.width - 2*pad) / Math.max(1e-6, maxX - minX);
      const sy = (canvas.height - 2*pad) / Math.max(1e-6, maxY - minY);
      const S = Math.min(sx, sy);
      const tx = (canvas.width - S*(maxX + minX)) / 2;
      const ty = (canvas.height - S*(maxY + minY)) / 2;
      for(let i=0;i<pos.length;i++) {
        pts2.push({ x: tx + S * pos[i][0], y: ty + S * pos[i][1] });
      }
    } else {
      // 3D projection
      if(!pos.length) return;
      const cy = Math.cos(yaw), sy = Math.sin(yaw);
      const cx = Math.cos(pitch), sxVal = Math.sin(pitch);
      let xMin=Infinity,xMax=-Infinity,yMin=Infinity,yMax=-Infinity;
      const rot = [];
      pos.forEach(p => {
        const x1 = cy*p[0] + sy*p[2];
        const z1 = -sy*p[0] + cy*p[2];
        const y1 = cx*p[1] - sxVal*z1;
        const z2 = sxVal*p[1] + cx*z1;
        rot.push([x1,y1,z2]);
        if(x1 < xMin) xMin = x1; if(x1 > xMax) xMax = x1;
        if(y1 < yMin) yMin = y1; if(y1 > yMax) yMax = y1;
      });
      const pad=30;
      const sx2 = (canvas.width - 2*pad) / Math.max(1e-6, xMax - xMin);
      const sy2 = (canvas.height - 2*pad) / Math.max(1e-6, yMax - yMin);
      const S = Math.min(sx2, sy2);
      const tx = (canvas.width - S*(xMax + xMin)) / 2;
      const ty = (canvas.height - S*(yMax + yMin)) / 2;
      rot.forEach(([x,y,z]) => {
        const f = 1/(1 + 0.2 * z);
        pts2.push({ x: tx + S*x*f, y: ty + S*y*f });
      });
    }
    // Draw neighbor edges
    if(method === 'neighbor' && showEdges && nmAdj.length === pos.length) {
      ctx.strokeStyle = '#94a3b8';
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.4;
      for(let i=0;i<nmAdj.length;i++) {
        nmAdj[i].forEach(j => {
          if(j > i) {
            const a = pts2[i];
            const b = pts2[j];
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        });
      }
      ctx.globalAlpha = 1;
    }
    // Draw points
    for(let i=0;i<pts2.length;i++) {
      const col = COLORS[points[i] ? (points[i].label % COLORS.length) : 0];
      ctx.fillStyle = col;
      ctx.globalAlpha = 0.95;
      ctx.beginPath();
      ctx.arc(pts2[i].x, pts2[i].y, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#ffffff';
      ctx.globalAlpha = 0.9;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    // Score and confetti
    const sc = scoreSeparationND(pos);
    refreshTitles(sc);
    if(sc >= target) {
      // draw confetti
      for(let k=0;k<40;k++) {
        const cx = Math.random() * canvas.width;
        const cy = Math.random() * canvas.height;
        const r = 2 + Math.random() * 3;
        const col = COLORS[k % COLORS.length];
        ctx.fillStyle = col;
        ctx.globalAlpha = 0.35;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
  }

  // ======== Event Handlers ========
  function handleClick(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    // Recompute screen coords (like draw) for nearest point detection
    let pts2 = [];
    if(D === 1) {
      if(!pos.length) return;
      let min=Infinity,max=-Infinity;
      pos.forEach(p => { if(p[0] < min) min=p[0]; if(p[0] > max) max=p[0]; });
      const pad=40; const S=(canvas.width - 2*pad)/Math.max(1e-6, max-min);
      const tx=(canvas.width - S*(max+min))/2;
      const midY=canvas.height * 0.55;
      for(let i=0;i<pos.length;i++) {
        const jitter = ((points[i].label * 7) % 5) - 2;
        pts2.push({ x: tx + S*pos[i][0], y: midY + jitter });
      }
    } else if(D === 2) {
      if(!pos.length) return;
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
      pos.forEach(p => {
        if(p[0] < minX) minX=p[0]; if(p[0] > maxX) maxX=p[0];
        if(p[1] < minY) minY=p[1]; if(p[1] > maxY) maxY=p[1];
      });
      const pad=30; const sx=(canvas.width-2*pad)/Math.max(1e-6,maxX-minX);
      const sy=(canvas.height-2*pad)/Math.max(1e-6,maxY-minY);
      const S=Math.min(sx,sy);
      const tx=(canvas.width - S*(maxX+minX))/2;
      const ty=(canvas.height - S*(maxY+minY))/2;
      for(let i=0;i<pos.length;i++) pts2.push({ x: tx + S*pos[i][0], y: ty + S*pos[i][1] });
    } else {
      const cy=Math.cos(yaw), sy=Math.sin(yaw), cx=Math.cos(pitch), sxVal=Math.sin(pitch);
      let xMin=Infinity,xMax=-Infinity,yMin=Infinity,yMax=-Infinity;
      const rot=[];
      pos.forEach(p => {
        const x1=cy*p[0]+sy*p[2];
        const z1=-sy*p[0]+cy*p[2];
        const y1=cx*p[1]-sxVal*z1;
        const z2=sxVal*p[1]+cx*z1;
        rot.push([x1,y1,z2]);
        if(x1 < xMin) xMin=x1; if(x1>xMax) xMax=x1;
        if(y1 < yMin) yMin=y1; if(y1>yMax) yMax=y1;
      });
      const pad=30; const sx2=(canvas.width-2*pad)/Math.max(1e-6,xMax-xMin);
      const sy2=(canvas.height-2*pad)/Math.max(1e-6,yMax-yMin);
      const S=Math.min(sx2,sy2);
      const tx=(canvas.width - S*(xMax+xMin))/2;
      const ty=(canvas.height - S*(yMax+yMin))/2;
      rot.forEach(([xv,yv,z]) => {
        const f=1/(1+0.2*z);
        pts2.push({ x: tx + S*xv*f, y: ty + S*yv*f });
      });
    }
    // find nearest point
    let bestIdx = -1, bestDist=Infinity;
    for(let i=0;i<pts2.length;i++) {
      const dx = x - pts2[i].x;
      const dy = y - pts2[i].y;
      const dist = dx*dx + dy*dy;
      if(dist < bestDist) { bestDist = dist; bestIdx = i; }
    }
    if(e.shiftKey) {
      // remove nearest
      if(bestIdx >= 0) {
        points.splice(bestIdx,1);
        pos.splice(bestIdx,1);
        projected.splice(bestIdx,1);
        computeAndAnimate();
      }
    } else {
      // add new point near this one
      if(bestIdx >= 0 && points[bestIdx]) {
        const base = points[bestIdx];
        const rgen = rng(seed + points.length * 13);
        const v = base.v.map(val => val + (rgen() - 0.5) * 0.3);
        points.push({ v, label: base.label });
        // immediate projection coordinate (approx)
        const basis = currentBasis();
        const centered = base.v.map((val,j) => val - (v[j] - val)); // not accurate but placeholder
        const newProj = projectND([v], basis)[0];
        pos.push(newProj.slice());
        computeAndAnimate();
      }
    }
  }

  // ======== Control bindings ========
  function initControls() {
    buildSegment(levelSeg, [
      { key:'blobs', label:'Level 1: Blobs' },
      { key:'moons', label:'Level 2: Twisty Moons' }
    ], level, key => {
      level = key;
      loadDataset();
      computeAndAnimate();
    });
    buildSegment(dimSeg, [
      { key:'1', label:'1D' }, { key:'2', label:'2D' }, { key:'3', label:'3D' }
    ], String(D), key => {
      D = parseInt(key,10);
      // reset weights to identity for new D
      const defs = [ [1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0] ];
      weights = defs.map(arr => arr.slice());
      manualRow.style.display = method === 'manual' ? '' : 'none';
      rot3dTools.style.display = (D === 3) ? '' : 'none';
      computeAndAnimate();
    });
    buildSegment(methodSeg, [
      { key:'manual', label:'Manual' },
      { key:'pca', label:'PCA' },
      { key:'rand', label:'Random' },
      { key:'neighbor', label:'Neighbor Map' }
    ], method, key => {
      method = key;
      manualRow.style.display = method === 'manual' ? '' : 'none';
      neighborTools.style.display = method === 'neighbor' ? '' : 'none';
      computeAndAnimate();
    });
    shuffleBtn.addEventListener('click', () => {
      shuffleData();
    });
    knnSlider.addEventListener('input', () => {
      if(method === 'neighbor') {
        nmAdj = knnGraph(points.map(p => p.v), parseInt(knnSlider.value, 10));
      }
    });
    autoBtn.addEventListener('click', () => {
      autoIter = !autoIter;
      autoBtn.textContent = autoIter ? 'Stop' : 'Auto';
    });
    stepBtn.addEventListener('click', () => {
      if(method === 'neighbor') {
        pos = neighborStepND(pos, nmAdj);
        iterCount++;
        iterLabel.textContent = String(iterCount);
      }
    });
    edgesChk.addEventListener('change', () => {
      showEdges = edgesChk.checked;
    });
    autoRotChk.addEventListener('change', () => {
      autoRotate3D = autoRotChk.checked;
    });
    hintPcaBtn.addEventListener('click', () => {
      const B = powerIterTopK(points.map(p => p.v), D);
      for(let dIdx=0; dIdx<D; dIdx++) {
        weights[dIdx] = B[dIdx].slice();
      }
      buildManualControls();
      if(method === 'manual') {
        computeAndAnimate();
      }
    });
    resetWeightsBtn.addEventListener('click', () => {
      const defs = [ [1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0] ];
      for(let dIdx=0; dIdx<D; dIdx++) weights[dIdx] = defs[dIdx].slice();
      buildManualControls();
      if(method === 'manual') computeAndAnimate();
    });
    canvas.addEventListener('click', handleClick);
    // Shift key removal uses event.shiftKey in handleClick
  }

  // ======== Animation Loop ========
  function animate() {
    draw();
    requestAnimationFrame(animate);
  }

  // ======== Setup ========
  function setup() {
    loadDataset();
    computeAndAnimate();
    initControls();
    buildManualControls();
    updateSpreads();
    refreshTitles(scoreSeparationND(pos));
    animate();
  }

  // Start
  setup();
})();
</script>
</body>
</html>
