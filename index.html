<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dimensionality Quest — p5.js Edition</title>
<!-- p5.js (single dependency, loads in the browser) -->
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
<style>
  :root { --bg:#f6f7ff; --ink:#111827; --muted:#6b7280; --card:#ffffff; --accent:#6366f1; }
  html, body { margin:0; padding:0; background: var(--bg); color: var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji"; }
  .wrap { max-width: 1050px; margin: 18px auto; padding: 0 12px; }
  h1 { font-size: 1.6rem; margin: 0 0 4px; }
  p.lead { margin: 0 0 12px; color: var(--muted); }
  .bar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 10px; }
  .seg { background: #eef2ff; border-radius: 999px; padding: 4px; display: inline-flex; gap: 4px; }
  .seg button { border: 0; background: transparent; padding: 8px 12px; border-radius: 999px; color: #374151; cursor: pointer; }
  .seg button.active { background: #ffffff; box-shadow: 0 1px 2px rgba(0,0,0,.08); color: #111827; font-weight: 600; }
  .btn { border: 0; background: var(--ink); color: white; padding: 8px 12px; border-radius: 12px; cursor: pointer; }
  .btn.alt { background: #4b5563; }
  .row { display: grid; grid-template-columns: 1fr; gap: 10px; }
  @media (min-width: 900px){ .row { grid-template-columns: 1fr 1fr; } }
  .card { background: var(--card); border-radius: 16px; box-shadow: 0 10px 24px rgba(0,0,0,.06); padding: 14px; }
  .titlebar { background: #111827; color: #fff; padding: 8px 12px; border-radius: 12px; font-weight: 600; font-size: 0.92rem; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
  .small { color: var(--muted); font-size: .9rem; }
  .kv { display:flex; align-items:center; gap:8px; }
  .slider { width: 160px; }
  canvas { width: 100%; height: auto; border-radius: 12px; border: 1px solid #e5e7eb; display:block; background: white; }
  .hint { font-size: .8rem; color: var(--muted); margin-top: 6px; }
  code { background: #eef2ff; padding: 2px 6px; border-radius: 8px; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Dimensionality Quest</h1>
  <p class="lead">Project hidden 5D treasure into 2D! Try different “magic glasses” (projections) and keep the colored groups apart.</p>

  <!-- Controls -->
  <div class="bar">
    <div class="seg" id="levelSeg"></div>
    <button class="btn" id="shuffleBtn">Shuffle dataset</button>
    <div style="width:1px;height:28px;background:#d1d5db"></div>
    <div class="seg" id="methodSeg"></div>

    <!-- Neighbor Map tools (shown when needed) -->
    <div class="kv" id="neighborTools" style="display:none">
      <label class="small">k-NN
        <input id="knnSlider" type="range" min="2" max="16" value="6" class="slider"/>
      </label>
      <button class="btn" id="autoBtn">Auto</button>
      <button class="btn alt" id="stepBtn">Step</button>
      <label class="small"><input type="checkbox" id="edgesChk"/> Show edges</label>
      <span class="small">Iterations: <b id="iterLabel">0</b></span>
    </div>
  </div>

  <!-- Canvas card -->
  <div class="card">
    <div class="titlebar">
      <div id="titleLeft">Dimensionality Quest — Manual Axes</div>
      <div id="titleRight">Score: 0.00 (goal 0.60)</div>
    </div>
    <div id="p5-holder"></div>
    <div class="hint">Tip: <b>Click</b> to add a point (inherits nearest color). <b>Shift+Click</b> to remove nearest. Switch methods to watch the cloud morph.</div>
  </div>

  <!-- Manual weights + Feature spread -->
  <div class="row" id="manualRow" style="margin-top:10px;">
    <div class="card">
      <div style="font-weight:600;margin-bottom:6px;">Choose your own axes (weights for 5D → X,Y)</div>
      <div id="weights"></div>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button class="btn alt" id="resetWeightsBtn">Reset</button>
        <button class="btn" id="hintPcaBtn">Use PCA as a hint</button>
      </div>
    </div>
    <div class="card">
      <div style="font-weight:600;margin-bottom:6px;">Which dimensions matter? (spread per feature)</div>
      <div id="spreads"></div>
      <div class="hint">PCA automatically finds directions with big spread.</div>
    </div>
  </div>

  <div class="row" style="margin-top:10px;">
    <div class="card">
      <div style="font-weight:600;margin-bottom:6px;">Goal</div>
      <div>Reach a <b id="goalLabel">score ≥ 0.60</b> by separating colors in 2D. Score measures how far color centers are compared to how wiggly each group is.</div>
      <div class="hint" style="margin-top:6px;">Level 1 (Blobs) is linear-friendly — PCA & Manual do great. Level 2 (Twisty Moons) is curvy — try Neighbor Map.</div>
    </div>
    <div class="card">
      <div style="font-weight:600;margin-bottom:6px;">Mini challenges</div>
      <ol style="margin: 0 0 0 20px;">
        <li>Level 1: Use <b>PCA</b>. Does it beat random? Then mimic PCA with Manual sliders.</li>
        <li>Level 1: Make X use mostly <code>d1</code> & <code>d2</code>, Y use <code>d3</code> — can you hit the goal?</li>
        <li>Level 2: Start with PCA, then switch to <b>Neighbor Map</b>. Turn on edges and watch clusters separate.</li>
        <li>Add some “rogue” clicks. Which method is robust?</li>
      </ol>
    </div>
  </div>
</div>

<script>
/* ===========================
   State & data
=========================== */
const COLORS = ["#ef4444","#10b981","#3b82f6","#f59e0b","#8b5cf6","#ec4899","#14b8a6","#eab308"];
const levelSeg = document.getElementById('levelSeg');
const methodSeg = document.getElementById('methodSeg');
const shuffleBtn = document.getElementById('shuffleBtn');
const neighborTools = document.getElementById('neighborTools');
const knnSlider = document.getElementById('knnSlider');
const autoBtn = document.getElementById('autoBtn');
const stepBtn = document.getElementById('stepBtn');
const edgesChk = document.getElementById('edgesChk');
const iterLabel = document.getElementById('iterLabel');
const manualRow = document.getElementById('manualRow');
const weightsDiv = document.getElementById('weights');
const spreadsDiv = document.getElementById('spreads');
const titleLeft = document.getElementById('titleLeft');
const titleRight = document.getElementById('titleRight');
const goalLabel = document.getElementById('goalLabel');
const hintPcaBtn = document.getElementById('hintPcaBtn');
const resetWeightsBtn = document.getElementById('resetWeightsBtn');

let W = 960, H = 600;
let method = 'manual'; // manual | pca | rand | neighbor
let level = 'blobs';   // blobs | moons
let seed = 1;
let auto = false;
let iter = 0;

let points = []; // [{v:[..5], label:int}]
let kClasses = 3;
let target = 0.60;

let weightsX = [1,0,0,0,0];
let weightsY = [0,1,0,0,0];

let projected = [];  // [{x,y}] latest target projection
let pos = [];        // animated current positions (for draw)
let tweenFrom = [];
let tweenTo = [];
let tweenT = 1;      // 0..1

// neighbor map state
let nmAdj = [];      // kNN adjacency (indices)
let showEdges = false;

/* ===========================
   Utils (math & rng)
=========================== */
function rng(seed){ let s=seed>>>0; return ()=> (s=(1664525*s+1013904223)>>>0, (s>>>0)/4294967296); }
function dot(a,b){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
function sub(a,b){ return a.map((x,i)=> x-b[i]); }
function add(a,b){ return a.map((x,i)=> x+b[i]); }
function mul(a,k){ return a.map(x=> x*k); }
function norm(v){ return Math.sqrt(Math.max(1e-12, dot(v,v))); }
function center(X){
  const d=X[0].length; const mu=new Array(d).fill(0);
  for(const v of X) for(let j=0;j<d;j++) mu[j]+=v[j];
  for(let j=0;j<d;j++) mu[j]/=X.length;
  const X0 = X.map(v=> sub(v, mu));
  return {X0, mu};
}

// power iteration for top-2 eigenvectors of covariance
function powerIterTop2(X){
  const d=X[0].length; const {X0} = center(X);
  function covAx(x){
    const n=X0.length; const tmp=new Array(n);
    for(let i=0;i<n;i++) tmp[i]=dot(X0[i], x);
    const y=new Array(d).fill(0);
    for(let j=0;j<d;j++){ let s=0; for(let i=0;i<n;i++) s+=X0[i][j]*tmp[i]; y[j]=s/n; }
    return y;
  }
  function topVec(defl){
    let x=new Array(d).fill(0).map(()=> Math.random()*2-1);
    for(let it=0; it<40; it++){
      let y=covAx(x);
      if(defl){ const qt=dot(defl.vec,x); for(let j=0;j<d;j++) y[j]-=defl.vec[j]*qt*defl.val; }
      const n=norm(y); x=y.map(v=> v/n);
    }
    const y=covAx(x); const val=dot(x,y);
    return {vec:x, val};
  }
  const q1=topVec(); const q2=topVec({vec:q1.vec, val:q1.val});
  return [q1.vec, q2.vec];
}

function projectLinear(X, B){ // B=[b1,b2]
  const {X0} = center(X);
  const b1=B[0], b2=B[1];
  const u1=b1.map(x=> x/Math.max(1e-9,norm(b1)));
  const u2=b2.map(x=> x/Math.max(1e-9,norm(b2)));
  return X0.map(v=> ({x: dot(v,u1), y: dot(v,u2)}));
}

function randomBasis(d=5){
  const r=rng(seed+123);
  function randVec(){ const v=new Array(d).fill(0).map(()=> r()*2-1); const n=norm(v); return v.map(x=> x/n); }
  const a=randVec(); let b=randVec(); const proj=dot(a,b); b=b.map((x,i)=> x - a[i]*proj); const nb=norm(b); b=b.map(x=> x/nb);
  return [a,b];
}

/* ===========================
   Datasets (5D)
=========================== */
function genBlobs(n=240, k=3){
  const r=rng(seed);
  const means = [
    [ 2.2,  0.5,  0.0, -1.5,  0.3],
    [-1.0,  2.0,  0.5,  0.8, -0.7],
    [ 0.2, -1.3,  1.7,  0.6,  1.2],
    [ 2.0,  1.2, -1.5,  0.0, -0.3],
    [-1.8, -0.6,  1.0, -1.2,  0.9],
  ];
  const pts=[];
  for(let i=0;i<n;i++){
    const c=i%k; const m=means[c];
    const v=m.map(mu => mu + (r()-0.5)*0.9);
    pts.push({ v, label:c });
  }
  return pts;
}
function genMoons(n=240){
  const r=rng(seed); const pts=[];
  for(let i=0;i<n/2;i++){
    const t=Math.PI*(i/(n/2));
    const base=[ 2.0*Math.cos(t), 1.2*Math.sin(t), 0.6*Math.cos(2*t), 0.6*Math.sin(2*t), 0.3*Math.cos(3*t) ];
    const v=base.map((b,j)=> b + (r()-0.5)*0.25*(j<2?1.0:0.7));
    pts.push({ v, label:0 });
  }
  for(let i=0;i<n/2;i++){
    const t=Math.PI*(i/(n/2));
    const base=[ 2.0*Math.cos(t)+1.8, -1.2*Math.sin(t)+0.5, 0.6*Math.cos(2*t+0.6), 0.6*Math.sin(2*t+0.6), 0.3*Math.cos(3*t+0.2) ];
    const v=base.map((b,j)=> b + (r()-0.5)*0.25*(j<2?1.0:0.7));
    pts.push({ v, label:1 });
  }
  return pts;
}

/* ===========================
   k-NN & Neighbor layout
=========================== */
function knnGraph(X,k=6){
  const n=X.length; const adj=Array.from({length:n}, ()=>[]);
  for(let i=0;i<n;i++){
    const ds=[];
    for(let j=0;j<n;j++){ if(i===j) continue;
      let s=0; for(let t=0;t<X[i].length;t++){ const u=X[i][t]-X[j][t]; s+=u*u; }
      ds.push({j, d:Math.sqrt(s)});
    }
    ds.sort((p,q)=> p.d-q.d);
    adj[i]=ds.slice(0, k).map(e=> e.j);
  }
  return adj;
}
function neighborStep(pos, adj){
  const n=pos.length; const next = pos.map(p=> ({x:p.x, y:p.y}));
  const kStiff=0.03, rest=0.7, repel=0.001;
  for(let i=0;i<n;i++){
    const pi=pos[i];
    for(const j of adj[i]){ if(j<=i) continue;
      const pj=pos[j]; const dx=pj.x-pi.x, dy=pj.y-pi.y; const dist=Math.hypot(dx,dy)+1e-6;
      const f=kStiff*(dist-rest); const fx=f*dx/dist, fy=f*dy/dist;
      next[i].x+=fx; next[i].y+=fy; next[j].x-=fx; next[j].y-=fy;
    }
  }
  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      const dx=next[j].x-next[i].x, dy=next[j].y-next[i].y; const d2=dx*dx+dy*dy+1e-6;
      const f=repel/d2; const fx=f*dx, fy=f*dy; next[i].x-=fx; next[i].y-=fy; next[j].x+=fx; next[j].y+=fy;
    }
  }
  return next;
}

/* ===========================
   Projection, scoring & tween
=========================== */
function computeProjection(){
  const X = points.map(p=> p.v);
  if (!X.length) return [];
  if (method==='manual') return projectLinear(X, [weightsX, weightsY]);
  if (method==='pca')    return projectLinear(X, powerIterTop2(X));
  if (method==='rand')   return projectLinear(X, randomBasis(5));
  // neighbor: start from PCA; live positions evolve separately
  return projectLinear(X, powerIterTop2(X));
}
function startTween(newTarget){
  tweenFrom = pos.map(p=> ({...p}));
  tweenTo = newTarget.map(p=> ({...p}));
  tweenT = 0;
}
function easeInOut(t){ return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

function scoreSeparation(XY){
  if (!XY.length) return 0;
  const k = kClasses;
  const groups = Array.from({length:k}, ()=>({sumX:0,sumY:0,n:0, idxs:[]}));
  for(let i=0;i<points.length;i++){
    const c=points[i].label; const p=XY[i];
    if (groups[c]) { groups[c].sumX+=p.x; groups[c].sumY+=p.y; groups[c].n++; groups[c].idxs.push(i); }
  }
  const mu={x:0,y:0}; for(const g of groups){ mu.x+=g.sumX; mu.y+=g.sumY; }
  mu.x/=points.length; mu.y/=points.length;
  let SB=0, SW=0;
  for(let c=0;c<k;c++) if (groups[c] && groups[c].n>0){
    const mx=groups[c].sumX/groups[c].n, my=groups[c].sumY/groups[c].n;
    const dx=mx-mu.x, dy=my-mu.y; SB += dx*dx+dy*dy;
    for(const idx of groups[c].idxs){ const p=XY[idx]; const ux=p.x-mx, uy=p.y-my; SW += ux*ux+uy*uy; }
  }
  const s = SB/(SW+1e-6);
  return Math.max(0, Math.min(1, s));
}

/* ===========================
   UI wiring
=========================== */
function seg(el, options, active, onPick){
  el.innerHTML='';
  options.forEach(o=>{
    const b=document.createElement('button');
    b.textContent=o.label;
    b.className = ' ' + (o.key===active ? 'active' : '');
    b.onclick=()=> onPick(o.key);
    el.appendChild(b);
  });
}

function buildManualControls(){
  weightsDiv.innerHTML='';
  for(let j=0;j<5;j++){
    const row=document.createElement('div');
    row.className='kv';
    row.innerHTML = `
      <span class="small" style="width:28px;">d${j+1}</span>
      <input type="range" min="-1" max="1" step="0.01" value="${weightsX[j]}" style="width:200px">
      <span class="small" style="width:42px; text-align:right;">${weightsX[j].toFixed(2)}</span>
      <span class="small" style="width:14px; text-align:center;">→</span>
      <input type="range" min="-1" max="1" step="0.01" value="${weightsY[j]}" style="width:200px">
      <span class="small" style="width:42px; text-align:right;">${weightsY[j].toFixed(2)}</span>
    `;
    const [lab, sx, vx, arrow, sy, vy] = row.children;
    sx.oninput = e => { weightsX[j]=parseFloat(e.target.value); vx.textContent=weightsX[j].toFixed(2); onWeightsChange(); };
    sy.oninput = e => { weightsY[j]=parseFloat(e.target.value); vy.textContent=weightsY[j].toFixed(2); onWeightsChange(); };
    weightsDiv.appendChild(row);
  }
}
function onWeightsChange(){
  if (method!=='manual') return;
  projected = computeProjection();
  startTween(projected);
}

function updateSpreads(){
  spreadsDiv.innerHTML='';
  if (!points.length){ return; }
  const X = points.map(p=> p.v); const d=5; const mu=new Array(d).fill(0);
  for(const v of X) for(let j=0;j<d;j++) mu[j]+=v[j]; for(let j=0;j<d;j++) mu[j]/=X.length;
  const s2=new Array(d).fill(0);
  for(const v of X) for(let j=0;j<d;j++){ const u=v[j]-mu[j]; s2[j]+=u*u; }
  const sd = s2.map(x=> Math.sqrt(x/Math.max(1, X.length-1)));
  for(let j=0;j<5;j++){
    const line=document.createElement('div');
    line.className='kv';
    const barW = Math.min(100, sd[j]*35);
    line.innerHTML = `
      <span class="small" style="width:28px;">d${j+1}</span>
      <div style="background:#f3f4f6;border-radius:999px;overflow:hidden;width:260px;height:8px;">
        <div style="background:#6366f1;height:8px;width:${barW}%"></div>
      </div>
      <span class="small" style="width:42px;text-align:right;">${sd[j].toFixed(2)}</span>
    `;
    spreadsDiv.appendChild(line);
  }
}

function refreshTitles(score){
  const name = method==='manual'?'Manual Axes': method==='pca'?'PCA-2D': method==='rand'?'Random Projection':'Neighbor Map';
  titleLeft.textContent = `Dimensionality Quest — ${name}`;
  titleRight.textContent = `Score: ${score.toFixed(2)} (goal ${target.toFixed(2)})`;
  goalLabel.textContent = `score ≥ ${target.toFixed(2)}`;
}

/* ===========================
   Dataset init / switching
=========================== */
function loadLevel(){
  if (level==='blobs'){ kClasses=3; target=0.60; points=genBlobs(240,3); }
  else { kClasses=2; target=0.55; points=genMoons(240); }
  // initial projection
  projected = computeProjection();
  pos = projected.map(p=> ({...p}));
  tweenT = 1;
  iter = 0; iterLabel.textContent = '0';
  updateSpreads();
  buildManualControls();
  refreshTitles(scoreSeparation(pos));
}

/* ===========================
   p5 sketch
=========================== */
let pg;
function setup(){
  const holder = document.getElementById('p5-holder');
  const dpr = window.devicePixelRatio || 1;
  const w = Math.min(1000, holder.clientWidth);
  const scale = w/960;
  W = Math.round(960*scale); H = Math.round(600*scale);

  pg = createCanvas(W, H);
  pg.parent('p5-holder');
  pixelDensity(dpr);

  // UI segments
  seg(levelSeg, [{key:'blobs',label:'Level 1: Blobs'},{key:'moons',label:'Level 2: Twisty Moons'}], level, key=>{
    level=key; loadLevel();
  });
  seg(methodSeg, [
    {key:'manual', label:'Manual Axes'},
    {key:'pca',    label:'PCA-2D'},
    {key:'rand',   label:'Random'},
    {key:'neighbor',label:'Neighbor Map'}
  ], method, key=>{
    method=key;
    manualRow.style.display = (method==='manual') ? '' : 'none';
    neighborTools.style.display = (method==='neighbor') ? '' : 'none';
    if (method==='neighbor'){
      // init neighbor positions/graph from PCA
      const X = points.map(p=> p.v);
      pos = projectLinear(X, powerIterTop2(X));
      nmAdj = knnGraph(X, parseInt(knnSlider.value,10));
      iter = 0; iterLabel.textContent = '0';
      tweenT=1; // direct
    } else {
      projected = computeProjection();
      startTween(projected);
    }
    refreshTitles(scoreSeparation(pos));
  });

  shuffleBtn.onclick = ()=> { seed++; loadLevel(); };
  knnSlider.oninput = ()=> {
    if (method==='neighbor'){
      nmAdj = knnGraph(points.map(p=> p.v), parseInt(knnSlider.value,10));
    }
  };
  edgesChk.onchange = ()=> { showEdges = edgesChk.checked; };
  autoBtn.onclick = ()=> { auto = !auto; autoBtn.textContent = auto ? 'Stop' : 'Auto'; };
  stepBtn.onclick = ()=> {
    if (method==='neighbor'){ pos = neighborStep(pos, nmAdj); iter++; iterLabel.textContent = ''+iter; }
  };
  hintPcaBtn.onclick = ()=> {
    const X=points.map(p=> p.v); const B=powerIterTop2(X);
    weightsX = B[0].slice(); weightsY = B[1].slice(); buildManualControls(); onWeightsChange();
  };
  resetWeightsBtn.onclick = ()=> { weightsX=[1,0,0,0,0]; weightsY=[0,1,0,0,0]; buildManualControls(); onWeightsChange(); };

  loadLevel();
}

function windowResized(){
  const holder = document.getElementById('p5-holder');
  const w = Math.min(1000, holder.clientWidth);
  const scale = w/960;
  W = Math.round(960*scale); H = Math.round(600*scale);
  resizeCanvas(W, H);
}

function draw(){
  background(245,247,255);
  // grid
  stroke(229,231,235); strokeWeight(1);
  for(let x=40; x<960; x+=40){
    const xx = x * (W/960);
    line(xx,0,xx,H);
  }
  for(let y=40; y<600; y+=40){
    const yy = y * (H/600);
    line(0,yy,W,yy);
  }

  // animate tween if needed
  if (tweenT < 1){
    tweenT = Math.min(1, tweenT + 0.025);
    const e = easeInOut(tweenT);
    for(let i=0;i<pos.length;i++){
      pos[i].x = tweenFrom[i].x + (tweenTo[i].x - tweenFrom[i].x)*e;
      pos[i].y = tweenFrom[i].y + (tweenTo[i].y - tweenFrom[i].y)*e;
    }
  }
  // neighbor auto iterate
  if (auto && method==='neighbor'){
    pos = neighborStep(pos, nmAdj);
    iter++; iterLabel.textContent = ''+iter;
  }

  // normalize to canvas box
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for(const p of pos){ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
  const pad=30; const sx=(W-2*pad)/Math.max(1e-6, maxX-minX); const sy=(H-2*pad)/Math.max(1e-6, maxY-minY);
  const S=Math.min(sx,sy); const tx = (W - S*(maxX+minX))/2; const ty = (H - S*(maxY+minY))/2;

  // edges (neighbor map)
  if (method==='neighbor' && showEdges && nmAdj.length===pos.length){
    stroke(148,163,184,120); strokeWeight(1);
    for(let i=0;i<nmAdj.length;i++){
      for(const j of nmAdj[i]) if (j>i){
        const a=pos[i], b=pos[j];
        line(tx+S*a.x, ty+S*a.y, tx+S*b.x, ty+S*b.y);
      }
    }
  }

  noStroke();
  // draw points
  for(let i=0;i<points.length;i++){
    const c = color(COLORS[points[i].label % COLORS.length]);
    c.setAlpha(240);
    fill(c);
    circle(tx+S*pos[i].x, ty+S*pos[i].y, 10);
    // white outline
    stroke(255); strokeWeight(1); noFill();
    circle(tx+S*pos[i].x, ty+S*pos[i].y, 10);
    noStroke();
  }

  // score & goal display + confetti
  const sc = scoreSeparation(pos); refreshTitles(sc);
  if (sc >= target){
    for(let k=0;k<60;k++){
      const cx=Math.random()*W, cy=Math.random()*H, r=2+Math.random()*3;
      const cc = color(COLORS[k % COLORS.length]); cc.setAlpha(90);
      noStroke(); fill(cc); circle(cx, cy, r);
    }
  }
}

// Click add / Shift+Click remove
function mousePressed(){
  const holder = document.getElementById('p5-holder');
  if (!holder.contains(canvas)) return;

  // Convert mouse to projection coordinates
  if (!pos.length) return;
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for(const p of pos){ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
  const pad=30; const sx=(W-2*pad)/Math.max(1e-6, maxX-minX); const sy=(H-2*pad)/Math.max(1e-6, maxY-minY);
  const S=Math.min(sx,sy); const tx = (W - S*(maxX+minX))/2; const ty = (H - S*(maxY+minY))/2;
  const px = (mouseX - tx)/S, py = (mouseY - ty)/S;

  // nearest
  let bi=-1, bd=Infinity;
  for(let i=0;i<pos.length;i++){
    const u=pos[i]; const d=(u.x-px)*(u.x-px)+(u.y-py)*(u.y-py); if (d<bd){ bd=d; bi=i; }
  }
  if (keyIsDown(SHIFT)){
    if (bi>=0){ points.splice(bi,1); pos.splice(bi,1); projected.splice(bi,1); }
    return false;
  } else {
    if (bi>=0){
      const base=points[bi];
      const r=rng(seed+points.length*13);
      const v = base.v.map(val=> val + (r()-0.5)*0.3);
      points.push({ v, label: base.label });
      // add at clicked position to feel responsive
      pos.push({ x:px, y:py });
      projected = computeProjection();
      startTween(projected);
      if (method==='neighbor'){ nmAdj = knnGraph(points.map(p=> p.v), parseInt(knnSlider.value,10)); }
    }
  }
  return false;
}
</script>
</body>
</html>
