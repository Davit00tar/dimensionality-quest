<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dimensionality Quest — 1D / 2D / 3D</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
<style>
  :root { --bg:#f6f7ff; --ink:#111827; --muted:#6b7280; --card:#ffffff; }
  html, body { margin:0; padding:0; background: var(--bg); color: var(--ink);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; }
  .wrap { max-width: 1050px; margin: 18px auto; padding: 0 12px; }
  h1 { font-size: 1.6rem; margin: 0 0 4px; }
  p.lead { margin: 0 0 12px; color: var(--muted); }
  .bar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:10px; }
  .seg { background:#eef2ff; border-radius:999px; padding:4px; display:inline-flex; gap:4px; }
  .seg button { border:0; background:transparent; padding:8px 12px; border-radius:999px; color:#374151; cursor:pointer; }
  .seg button.active { background:#fff; box-shadow:0 1px 2px rgba(0,0,0,.08); color:#111827; font-weight:600; }
  .btn { border:0; background:#111827; color:#fff; padding:8px 12px; border-radius:12px; cursor:pointer; }
  .btn.alt { background:#4b5563; }
  .small { color:var(--muted); font-size:.9rem; }
  .card { background:var(--card); border-radius:16px; box-shadow:0 10px 24px rgba(0,0,0,.06); padding:14px; }
  .titlebar { background:#111827; color:#fff; padding:8px 12px; border-radius:12px; font-weight:600; font-size:.92rem;
    display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
  .row { display:grid; grid-template-columns:1fr; gap:10px; }
  @media (min-width: 900px){ .row { grid-template-columns:1fr 1fr; } }
  .kv { display:flex; align-items:center; gap:8px; }
  .slider { width: 160px; }
  canvas { width: 100%; height: auto; border-radius: 12px; border: 1px solid #e5e7eb; display:block; background:white; }
  .hint { font-size:.8rem; color:var(--muted); margin-top:6px; }
  code { background:#eef2ff; padding:2px 6px; border-radius:8px; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Dimensionality Quest</h1>
  <p class="lead">We have hidden <b>5D</b> treasure. Put on different “magic glasses” to see it in <b>1D</b>, <b>2D</b>, or <b>3D</b> — without losing patterns!</p>

  <div class="bar">
    <div class="seg" id="levelSeg"></div>
    <div class="seg" id="dimSeg" style="margin-left:4px;"></div>
    <button class="btn" id="shuffleBtn">Shuffle dataset</button>
    <div style="width:1px;height:28px;background:#d1d5db"></div>
    <div class="seg" id="methodSeg"></div>

    <div class="kv" id="neighborTools" style="display:none">
      <label class="small">k-NN
        <input id="knnSlider" type="range" min="2" max="16" value="6" class="slider"/>
      </label>
      <button class="btn" id="autoBtn">Auto</button>
      <button class="btn alt" id="stepBtn">Step</button>
      <label class="small"><input type="checkbox" id="edgesChk"/> Show edges</label>
      <span class="small">Iterations: <b id="iterLabel">0</b></span>
    </div>

    <div class="kv" id="rot3dTools" style="display:none">
      <label class="small"><input type="checkbox" id="autoRotChk" checked/> Auto-rotate 3D</label>
    </div>
  </div>

  <div class="card">
    <div class="titlebar">
      <div id="titleLeft">Dimensionality Quest — Manual Axes (2D)</div>
      <div id="titleRight">Score: 0.00 (goal 0.60)</div>
    </div>
    <div id="p5-holder"></div>
    <div class="hint">Tip: <b>Click</b> to add a point (inherits nearest color). <b>Shift+Click</b> to remove nearest. Switch methods to watch the cloud morph.</div>
  </div>

  <div class="row" id="manualRow" style="margin-top:10px;">
    <div class="card">
      <div style="font-weight:600;margin-bottom:6px;">Choose your own axes (weights for 5D → 1D / 2D / 3D)</div>
      <div id="weights"></div>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button class="btn alt" id="resetWeightsBtn">Reset</button>
        <button class="btn" id="hintPcaBtn">Use PCA as a hint</button>
      </div>
    </div>
    <div class="card">
      <div style="font-weight:600;margin-bottom:6px;">Which dimensions matter? (spread per feature)</div>
      <div id="spreads"></div>
      <div class="hint">PCA automatically finds directions with big spread.</div>
    </div>
  </div>

  <div class="row" style="margin-top:10px;">
    <div class="card">
      <div style="font-weight:600;margin-bottom:6px;">Goal</div>
      <div>Reach a <b id="goalLabel">score ≥ 0.60</b> by separating colors after projection. The score compares how far color centers are vs. how wiggly each group is.</div>
      <div class="hint" style="margin-top:6px;">Level 1 (Blobs) is linear-friendly — PCA & Manual do great. Level 2 (Twisty Moons) is curvy — try Neighbor Map.</div>
    </div>
    <div class="card">
      <div style="font-weight:600;margin-bottom:6px;">Mini challenges</div>
      <ol style="margin: 0 0 0 20px;">
        <li>Pick <b>2D</b> + <b>PCA</b>. Does it beat random? Then mimic it with Manual sliders.</li>
        <li>Try <b>1D</b>: can you keep colors apart on a line?</li>
        <li>Switch to <b>3D</b> and rotate — does 3D reveal patterns hidden in 2D?</li>
        <li>Level 2 + <b>Neighbor Map</b>: turn on edges, Step/Auto to untangle the moons.</li>
      </ol>
    </div>
  </div>
</div>

<script>
/* ===========================
   Globals & state
=========================== */
const COLORS = ["#ef4444","#10b981","#3b82f6","#f59e0b","#8b5cf6","#ec4899","#14b8a6","#eab308"];

const levelSeg = document.getElementById('levelSeg');
const dimSeg = document.getElementById('dimSeg');
const methodSeg = document.getElementById('methodSeg');
const shuffleBtn = document.getElementById('shuffleBtn');

const neighborTools = document.getElementById('neighborTools');
const knnSlider = document.getElementById('knnSlider');
const autoBtn = document.getElementById('autoBtn');
const stepBtn = document.getElementById('stepBtn');
const edgesChk = document.getElementById('edgesChk');
const iterLabel = document.getElementById('iterLabel');

const rot3dTools = document.getElementById('rot3dTools');
const autoRotChk = document.getElementById('autoRotChk');

const manualRow = document.getElementById('manualRow');
const weightsDiv = document.getElementById('weights');
const spreadsDiv = document.getElementById('spreads');
const titleLeft = document.getElementById('titleLeft');
const titleRight = document.getElementById('titleRight');
const goalLabel = document.getElementById('goalLabel');
const hintPcaBtn = document.getElementById('hintPcaBtn');
const resetWeightsBtn = document.getElementById('resetWeightsBtn');

let W=960, H=600;
let level='blobs';              // blobs | moons
let D=2;                        // 1 | 2 | 3  (output dimension)
let method='manual';            // manual | pca | rand | neighbor
let seed=1;

let points=[];                  // [{v:[5], label:int}]
let kClasses=3;
let target=0.60;

let weights = [                // weights[d][5]
  [1,0,0,0,0],
  [0,1,0,0,0],
  [0,0,1,0,0]
];

let projected=[];              // array of arrays length D
let pos=[];                    // current positions (animated), arrays length D
let tweenFrom=[], tweenTo=[], tweenT=1;

let nmAdj=[];                  // kNN adjacency
let auto=false, iter=0, showEdges=false;

// 3D view angles
let yaw=0.6, pitch=0.3;

/* ===========================
   Math helpers
=========================== */
function rng(seed){ let s=seed>>>0; return ()=> (s=(1664525*s+1013904223)>>>0, (s>>>0)/4294967296); }
function dot(a,b){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
function sub(a,b){ return a.map((x,i)=> x-b[i]); }
function norm(v){ return Math.sqrt(Math.max(1e-12, dot(v,v))); }
function center(X){
  const d=X[0].length; const mu=new Array(d).fill(0);
  for(const v of X) for(let j=0;j<d;j++) mu[j]+=v[j];
  for(let j=0;j<d;j++) mu[j]/=X.length;
  return { X0: X.map(v=> v.map((x,j)=> x-mu[j])), mu };
}
function powerIterTopK(X, K){
  const d=X[0].length; const {X0} = center(X);
  function covAx(x){
    const n=X0.length; const tmp=new Array(n);
    for(let i=0;i<n;i++) tmp[i]=dot(X0[i], x);
    const y=new Array(d).fill(0);
    for(let j=0;j<d;j++){ let s=0; for(let i=0;i<n;i++) s+=X0[i][j]*tmp[i]; y[j]=s/n; }
    return y;
  }
  function topVec(defls){
    let x=new Array(d).fill(0).map(()=> Math.random()*2-1);
    for(let it=0; it<40; it++){
      let y=covAx(x);
      if (defls && defls.length){
        for(const {vec,val} of defls){ const qt=dot(vec,x); for(let j=0;j<d;j++) y[j]-=vec[j]*qt*val; }
      }
      const n=norm(y); x=y.map(v=> v/n);
    }
    const y=covAx(x); const val=dot(x,y);
    return {vec:x, val};
  }
  const out=[]; const defls=[];
  for(let k=0;k<K;k++){ const t=topVec(defls); out.push(t.vec); defls.push(t); }
  return out; // array of K vectors
}
function randomOrtho(d=5, K=2, seedBump=0){
  const r=rng(seed+123+seedBump);
  function randVec(){ const v=Array(d).fill(0).map(()=> r()*2-1); const n=norm(v); return v.map(x=> x/n); }
  const basis=[];
  for(let k=0;k<K;k++){
    let v=randVec();
    for(let i=0;i<basis.length;i++){ const proj = dot(basis[i], v); v=v.map((x,j)=> x - basis[i][j]*proj); }
    const nv=norm(v); basis.push(v.map(x=> x/nv));
  }
  return basis;
}
function projectND(X, basis){ // basis: K vectors length 5
  const {X0} = center(X);
  const U = basis.map(b => b.map(x=> x/Math.max(1e-9, norm(b)))); // normalize each axis
  return X0.map(v => U.map(u => dot(v,u))); // returns array length K
}

/* ===========================
   Datasets (5D)
=========================== */
function genBlobs(n=240, k=3){
  const r=rng(seed);
  const means = [
    [ 2.2,  0.5,  0.0, -1.5,  0.3],
    [-1.0,  2.0,  0.5,  0.8, -0.7],
    [ 0.2, -1.3,  1.7,  0.6,  1.2],
    [ 2.0,  1.2, -1.5,  0.0, -0.3],
    [-1.8, -0.6,  1.0, -1.2,  0.9],
  ];
  const pts=[];
  for(let i=0;i<n;i++){
    const c=i%k; const m=means[c];
    const v=m.map(mu => mu + (r()-0.5)*0.9);
    pts.push({ v, label:c });
  }
  return pts;
}
function genMoons(n=240){
  const r=rng(seed); const pts=[];
  for(let i=0;i<n/2;i++){
    const t=Math.PI*(i/(n/2));
    const base=[ 2.0*Math.cos(t), 1.2*Math.sin(t), 0.6*Math.cos(2*t), 0.6*Math.sin(2*t), 0.3*Math.cos(3*t) ];
    const v=base.map((b,j)=> b + (r()-0.5)*0.25*(j<2?1.0:0.7));
    pts.push({ v, label:0 });
  }
  for(let i=0;i<n/2;i++){
    const t=Math.PI*(i/(n/2));
    const base=[ 2.0*Math.cos(t)+1.8, -1.2*Math.sin(t)+0.5, 0.6*Math.cos(2*t+0.6), 0.6*Math.sin(2*t+0.6), 0.3*Math.cos(3*t+0.2) ];
    const v=base.map((b,j)=> b + (r()-0.5)*0.25*(j<2?1.0:0.7));
    pts.push({ v, label:1 });
  }
  return pts;
}

/* ===========================
   Neighbor layout (generic D)
=========================== */
function knnGraph(X,k=6){
  const n=X.length; const adj=Array.from({length:n}, ()=>[]);
  for(let i=0;i<n;i++){
    const ds=[];
    for(let j=0;j<n;j++){ if(i===j) continue;
      let s=0; for(let t=0;t<X[i].length;t++){ const u=X[i][t]-X[j][t]; s+=u*u; }
      ds.push({j, d:Math.sqrt(s)});
    }
    ds.sort((p,q)=> p.d-q.d);
    adj[i]=ds.slice(0, k).map(e=> e.j);
  }
  return adj;
}
function neighborStepND(pos, adj){ // pos: array of arrays length D
  const n=pos.length; const D=pos[0].length;
  const next = pos.map(p=> p.slice());
  const kStiff=0.03, rest=0.7, repel=0.001;
  for(let i=0;i<n;i++){
    for(const j of adj[i]){ if(j<=i) continue;
      let dx=new Array(D).fill(0), dist2=1e-9;
      for(let d=0; d<D; d++){ dx[d] = pos[j][d] - pos[i][d]; dist2 += dx[d]*dx[d]; }
      const dist=Math.sqrt(dist2);
      const f=kStiff*(dist - rest);
      for(let d=0; d<D; d++){
        const comp = f*dx[d]/dist;
        next[i][d] += comp;
        next[j][d] -= comp;
      }
    }
  }
  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      let dx=new Array(D).fill(0), d2=1e-9;
      for(let d=0; d<D; d++){ dx[d] = next[j][d]-next[i][d]; d2 += dx[d]*dx[d]; }
      const f = repel/d2;
      for(let d=0; d<D; d++){ const comp=f*dx[d]; next[i][d]-=comp; next[j][d]+=comp; }
    }
  }
  return next;
}

/* ===========================
   Projection + scoring
=========================== */
function currentBasis(){
  if (method==='manual')  return weights.slice(0, D);
  if (method==='pca')     return powerIterTopK(points.map(p=> p.v), D);
  if (method==='rand')    return randomOrtho(5, D, 77);
  // neighbor uses PCA init for coordinates
  return powerIterTopK(points.map(p=> p.v), D);
}
function computeProjection(){
  const X = points.map(p=> p.v);
  if (!X.length) return [];
  return projectND(X, currentBasis()); // returns array length D
}
function startTween(newTarget){
  tweenFrom = pos.map(p=> p.slice());
  tweenTo = newTarget.map(p=> p.slice());
  tweenT = 0;
}
function easeInOut(t){ return t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2; }

function scoreSeparationND(P){ // P: arrays length D
  if (!P.length) return 0;
  const k = kClasses;
  const groups = Array.from({length:k}, ()=>({sum:[], n:0, idxs:[]}));
  for(let c=0;c<k;c++) groups[c].sum = new Array(D).fill(0);
  for(let i=0;i<P.length;i++){
    const c = points[i].label; const p=P[i];
    if (groups[c]){
      for(let d=0; d<D; d++) groups[c].sum[d]+=p[d];
      groups[c].n++; groups[c].idxs.push(i);
    }
  }
  const mu = new Array(D).fill(0);
  for(const g of groups){ for(let d=0; d<D; d++) mu[d]+=g.sum[d]; }
  for(let d=0; d<D; d++) mu[d]/=P.length;

  let SB=0, SW=0;
  for(let c=0;c<k;c++) if (groups[c] && groups[c].n>0){
    const mc = groups[c].sum.map(s=> s/groups[c].n);
    SB += mc.reduce((s,mc_d,d)=> s + (mc_d-mu[d])**2, 0);
    for(const idx of groups[c].idxs){
      const p=P[idx];
      SW += p.reduce((s,pd,d)=> s + (pd-mc[d])**2, 0);
    }
  }
  return Math.max(0, Math.min(1, SB/(SW+1e-6)));
}

/* ===========================
   UI builders
=========================== */
function seg(el, options, active, onPick){
  el.innerHTML='';
  options.forEach(o=>{
    const b=document.createElement('button');
    b.textContent=o.label;
    b.className = (o.key===active ? 'active' : '');
    b.onclick=()=> onPick(o.key);
    el.appendChild(b);
  });
}
function buildManualControls(){
  weightsDiv.innerHTML='';
  for(let j=0;j<5;j++){
    const row=document.createElement('div'); row.className='kv';
    const sliderCells=[];
    let inner = `<span class="small" style="width:28px;">d${j+1}</span>`;
    for(let d=0; d<D; d++){
      inner += `
        <input type="range" min="-1" max="1" step="0.01" value="${weights[d][j]}" style="width:200px">
        <span class="small" style="width:42px;text-align:right;">${weights[d][j].toFixed(2)}</span>
        ${d < D-1 ? '<span class="small" style="width:14px;text-align:center;">→</span>' : '' }
      `;
    }
    row.innerHTML = inner;
    // attach listeners
    let idx=0;
    for(let d=0; d<D; d++){
      const slider = row.children[++idx];  // skip label
      const valLbl = row.children[++idx];
      slider.oninput = e => { weights[d][j]=parseFloat(e.target.value); valLbl.textContent=weights[d][j].toFixed(2); onWeightsChange(); };
      if (d < D-1) idx++; // skip arrow
    }
    weightsDiv.appendChild(row);
  }
}
function onWeightsChange(){
  if (method!=='manual') return;
  projected = computeProjection();
  startTween(projected);
}
function updateSpreads(){
  spreadsDiv.innerHTML='';
  if (!points.length) return;
  const X = points.map(p=> p.v); const d=5; const mu=new Array(d).fill(0);
  for(const v of X) for(let j=0;j<d;j++) mu[j]+=v[j]; for(let j=0;j<d;j++) mu[j]/=X.length;
  const s2=new Array(d).fill(0);
  for(const v of X) for(let j=0;j<d;j++){ const u=v[j]-mu[j]; s2[j]+=u*u; }
  const sd = s2.map(x=> Math.sqrt(x/Math.max(1, X.length-1)));
  for(let j=0;j<5;j++){
    const line=document.createElement('div'); line.className='kv';
    const barW = Math.min(100, sd[j]*35);
    line.innerHTML = `
      <span class="small" style="width:28px;">d${j+1}</span>
      <div style="background:#f3f4f6;border-radius:999px;overflow:hidden;width:260px;height:8px;">
        <div style="background:#6366f1;height:8px;width:${barW}%"></div>
      </div>
      <span class="small" style="width:42px;text-align:right;">${sd[j].toFixed(2)}</span>
    `;
    spreadsDiv.appendChild(line);
  }
}
function refreshTitles(score){
  const mname = method==='manual'?'Manual Axes': method==='pca'?'PCA': method==='rand'?'Random':'Neighbor Map';
  titleLeft.textContent = `Dimensionality Quest — ${mname} (${D}D)`;
  titleRight.textContent = `Score: ${score.toFixed(2)} (goal ${target.toFixed(2)})`;
  goalLabel.textContent = `score ≥ ${target.toFixed(2)}`;
}

/* ===========================
   Dataset init / switching
=========================== */
function loadLevel(){
  if (level==='blobs'){ kClasses=3; target=0.60; points=genBlobs(240,3); }
  else { kClasses=2; target=0.55; points=genMoons(240); }

  projected = computeProjection();
  pos = projected.map(p=> p.slice());
  tweenT=1; iter=0; iterLabel.textContent='0';
  updateSpreads(); buildManualControls(); refreshTitles(scoreSeparationND(pos));
}
function onDimChange(newD){
  D = parseInt(newD,10);
  // reset manual weights defaults for new D
  const defaults = [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0]];
  weights = [defaults[0].slice(), defaults[1].slice(), defaults[2].slice()];
  buildManualControls();
  // re-init positions for current method
  if (method==='neighbor'){
    pos = computeProjection(); // PCA init
    nmAdj = knnGraph(points.map(p=> p.v), parseInt(knnSlider.value,10));
    tweenT=1;
  } else {
    projected = computeProjection();
    pos = projected.map(p=> p.slice());
    tweenT=1;
  }
  refreshTitles(scoreSeparationND(pos));
}

/* ===========================
   p5 sketch (single canvas)
=========================== */
let renderer; // p5.Renderer
function setup(){
  const holder = document.getElementById('p5-holder');
  const dpr = window.devicePixelRatio || 1;
  const w = Math.min(1000, holder.clientWidth);
  const scale = w/960; W = Math.round(960*scale); H = Math.round(600*scale);

  renderer = createCanvas(W, H);
  renderer.parent('p5-holder');
  pixelDensity(dpr);

  seg(levelSeg, [{key:'blobs',label:'Level 1: Blobs'},{key:'moons',label:'Level 2: Twisty Moons'}], level, key=>{
    level=key; loadLevel();
  });
  seg(dimSeg, [{key:'1',label:'1D'},{key:'2',label:'2D'},{key:'3',label:'3D'}], ''+D, key=>{
    onDimChange(key);
    rot3dTools.style.display = (D===3) ? '' : 'none';
  });
  seg(methodSeg, [
    {key:'manual', label:'Manual Axes'},
    {key:'pca',    label:'PCA'},
    {key:'rand',   label:'Random'},
    {key:'neighbor',label:'Neighbor Map'}
  ], method, key=>{
    method=key;
    manualRow.style.display = (method==='manual') ? '' : 'none';
    neighborTools.style.display = (method==='neighbor') ? '' : 'none';
    if (method==='neighbor'){
      pos = computeProjection(); // PCA init
      nmAdj = knnGraph(points.map(p=> p.v), parseInt(knnSlider.value,10));
      iter=0; iterLabel.textContent='0'; tweenT=1;
    } else {
      projected = computeProjection();
      startTween(projected);
    }
    refreshTitles(scoreSeparationND(pos));
  });

  shuffleBtn.onclick = ()=> { seed++; loadLevel(); };
  knnSlider.oninput = ()=> { if (method==='neighbor') nmAdj = knnGraph(points.map(p=> p.v), parseInt(knnSlider.value,10)); };
  edgesChk.onchange = ()=> { showEdges = edgesChk.checked; };
  autoBtn.onclick = ()=> { auto = !auto; autoBtn.textContent = auto ? 'Stop' : 'Auto'; };
  stepBtn.onclick = ()=> { if (method==='neighbor'){ pos = neighborStepND(pos, nmAdj); iter++; iterLabel.textContent=''+iter; } };
  hintPcaBtn.onclick = ()=> {
    const B = powerIterTopK(points.map(p=> p.v), D);
    for(let d=0; d<D; d++) weights[d] = B[d].slice();
    buildManualControls(); onWeightsChange();
  };
  resetWeightsBtn.onclick = ()=> {
    const defaults = [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0]];
    for(let d=0; d<D; d++) weights[d] = defaults[d].slice();
    buildManualControls(); onWeightsChange();
  };

  rot3dTools.style.display = (D===3) ? '' : 'none';

  loadLevel();
}
function windowResized(){
  const holder = document.getElementById('p5-holder');
  const w = Math.min(1000, holder.clientWidth);
  const scale = w/960; W = Math.round(960*scale); H = Math.round(600*scale);
  resizeCanvas(W, H);
}
function draw(){
  background(245,247,255);
  stroke(229,231,235); strokeWeight(1);
  for(let x=40; x<960; x+=40){ const xx=x*(W/960); line(xx,0,xx,H); }
  for(let y=40; y<600; y+=40){ const yy=y*(H/600); line(0,yy,W,yy); }

  // tween animation
  if (tweenT < 1){
    tweenT = Math.min(1, tweenT + 0.025);
    const e = easeInOut(tweenT);
    for(let i=0;i<pos.length;i++){
      for(let d=0; d<D; d++){
        pos[i][d] = tweenFrom[i][d] + (tweenTo[i][d] - tweenFrom[i][d]) * e;
      }
    }
  }
  // neighbor auto
  if (auto && method==='neighbor'){ pos = neighborStepND(pos, nmAdj); iter++; iterLabel.textContent=''+iter; }

  // build 2D screen coords from current D
  let pts2 = [];
  if (D===1){
    // normalize 1D
    let min=Infinity,max=-Infinity; for(const p of pos){ if(p[0]<min)min=p[0]; if(p[0]>max)max=p[0]; }
    const padX=40; const S=(W-2*padX)/Math.max(1e-6, max-min); const tx=(W - S*(max+min))/2;
    const midY = H*0.55;
    for(let i=0;i<pos.length;i++){
      // little label-specific jitter so points don't sit exactly on top of each other
      const jitter = (points[i].label*7 % 5) - 2; // -2..+2
      pts2.push({ x: tx + S*pos[i][0], y: midY + jitter });
    }
  } else if (D===2){
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of pos){ if(p[0]<minX)minX=p[0]; if(p[0]>maxX)maxX=p[0]; if(p[1]<minY)minY=p[1]; if(p[1]>maxY)maxY=p[1]; }
    const pad=30; const sx=(W-2*pad)/Math.max(1e-6, maxX-minX); const sy=(H-2*pad)/Math.max(1e-6, maxY-minY);
    const S=Math.min(sx,sy); const tx=(W - S*(maxX+minX))/2; const ty=(H - S*(maxY+minY))/2;
    for(let i=0;i<pos.length;i++) pts2.push({ x: tx + S*pos[i][0], y: ty + S*pos[i][1] });
  } else { // 3D → 2D projection (rotate + weak perspective)
    if (autoRotChk.checked) yaw += 0.01;
    const cy=Math.cos(yaw), sy=Math.sin(yaw), cx=Math.cos(pitch), sx=Math.sin(pitch);
    let xMin=Infinity,xMax=-Infinity,yMin=Infinity,yMax=-Infinity;
    const rot=[]; // rotated coords
    for(const p of pos){
      // rotate around Y then X
      const x1 =  cy*p[0] + sy*p[2];
      const z1 = -sy*p[0] + cy*p[2];
      const y1 =  cx*p[1] - sx*z1;
      const z2 =  sx*p[1] + cx*z1;
      rot.push([x1,y1,z2]);
      if (x1<xMin) xMin=x1; if (x1>xMax) xMax=x1;
      if (y1<yMin) yMin=y1; if (y1>yMax) yMax=y1;
    }
    const pad=30; const sx2=(W-2*pad)/Math.max(1e-6,xMax-xMin); const sy2=(H-2*pad)/Math.max(1e-6,yMax-yMin);
    const S=Math.min(sx2, sy2);
    const tx=(W - S*(xMax+xMin))/2; const ty=(H - S*(yMax+yMin))/2;
    for(let i=0;i<rot.length;i++){
      const [x,y,z]=rot[i];
      const f = 1/(1 + 0.2*z); // mild perspective
      pts2.push({ x: tx + S*x*f, y: ty + S*y*f });
    }
  }

  // edges for neighbor map in 2D view
  if (method==='neighbor' && showEdges && nmAdj.length===pos.length){
    stroke(148,163,184,120); strokeWeight(1);
    for(let i=0;i<nmAdj.length;i++){
      for(const j of nmAdj[i]) if (j>i){
        const a=pts2[i], b=pts2[j]; line(a.x, a.y, b.x, b.y);
      }
    }
  }

  // draw points
  noStroke();
  for(let i=0;i<pts2.length;i++){
    const c = color(COLORS[points[i].label % COLORS.length]); c.setAlpha(240);
    fill(c); circle(pts2[i].x, pts2[i].y, 10);
    stroke(255); strokeWeight(1); noFill(); circle(pts2[i].x, pts2[i].y, 10); noStroke();
  }

  // score + confetti
  const sc = scoreSeparationND(pos);
  refreshTitles(sc);
  if (sc >= target){
    for(let k=0;k<60;k++){
      const cx=Math.random()*W, cy=Math.random()*H, r=2+Math.random()*3;
      const cc = color(COLORS[k % COLORS.length]); cc.setAlpha(90);
      noStroke(); fill(cc); circle(cx, cy, r);
    }
  }
}

// Click: add / Shift+Click: remove nearest (screen-space)
function mousePressed(){
  // Only handle clicks inside our canvas element
  if (!renderer || mouseX < 0 || mouseY < 0 || mouseX > width || mouseY > height) return false;

  // Use current 2D screen coordinates pts2 as in draw()
  // Recompute quick screen coords (same as draw path)
  let pts2=[];
  if (D===1){
    let min=Infinity,max=-Infinity; for(const p of pos){ if(p[0]<min)min=p[0]; if(p[0]>max)max=p[0]; }
    const padX=40; const S=(W-2*padX)/Math.max(1e-6, max-min); const tx=(W - S*(max+min))/2;
    const midY = H*0.55;
    for(let i=0;i<pos.length;i++){ const jitter=((points[i].label*7)%5)-2; pts2.push({ x: tx + S*pos[i][0], y: midY + jitter }); }
  } else if (D===2){
    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    for(const p of pos){ if(p[0]<minX)minX=p[0]; if(p[0]>maxX)maxX=p[0]; if(p[1]<minY)minY=p[1]; if(p[1]>maxY)maxY=p[1]; }
    const pad=30; const sx=(W-2*pad)/Math.max(1e-6, maxX-minX); const sy=(H-2*pad)/Math.max(1e-6, maxY-minY);
    const S=Math.min(sx,sy); const tx=(W - S*(maxX+minX))/2; const ty=(H - S*(maxY+minY))/2;
    for(let i=0;i<pos.length;i++) pts2.push({ x: tx + S*pos[i][0], y: ty + S*pos[i][1] });
  } else {
    const cy=Math.cos(yaw), sy=Math.sin(yaw), cx=Math.cos(pitch), sx=Math.sin(pitch);
    let xMin=Infinity,xMax=-Infinity,yMin=Infinity,yMax=-Infinity;
    const rot=[];
    for(const p of pos){
      const x1 =  cy*p[0] + sy*p[2];
      const z1 = -sy*p[0] + cy*p[2];
      const y1 =  cx*p[1] - sx*z1;
      const z2 =  sx*p[1] + cx*z1;
      rot.push([x1,y1,z2]);
      if (x1<xMin) xMin=x1; if (x1>xMax) xMax=x1;
      if (y1<yMin) yMin=y1; if (y1>yMax) yMax=y1;
    }
    const pad=30; const sx2=(W-2*pad)/Math.max(1e-6,xMax-xMin); const sy2=(H-2*pad)/Math.max(1e-6,yMax-yMin);
    const S=Math.min(sx2, sy2);
    const tx=(W - S*(xMax+xMin))/2; const ty=(H - S*(yMax+yMin))/2;
    for(let i=0;i<rot.length;i++){ const [x,y,z]=rot[i]; const f=1/(1+0.2*z); pts2.push({ x: tx + S*x*f, y: ty + S*y*f }); }
  }

  // find nearest screen-space point
  let bi=-1, bd=Infinity;
  for(let i=0;i<pts2.length;i++){
    const dx=mouseX-pts2[i].x, dy=mouseY-pts2[i].y; const d=dx*dx+dy*dy;
    if (d<bd){ bd=d; bi=i; }
  }
  if (keyIsDown(SHIFT)){
    if (bi>=0){ points.splice(bi,1); pos.splice(bi,1); projected.splice(bi,1); }
  } else {
    if (bi>=0){
      const base = points[bi];
      const r = rng(seed+points.length*13);
      const v = base.v.map(val=> val + (r()-0.5)*0.3);
      points.push({ v, label: base.label });
      // compute its projected coordinate immediately
      const newProj = projectND([v], currentBasis())[0];
      pos.push(newProj.slice());
      if (method==='neighbor') nmAdj = knnGraph(points.map(p=> p.v), parseInt(knnSlider.value,10));
      projected = computeProjection();
      startTween(projected);
    }
  }
  return false;
}
</script>
</body>
</html>
