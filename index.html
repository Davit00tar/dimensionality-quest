<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dimensionality Quest</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 UMD + Babel for in-browser JSX -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body { margin:0; padding:0; background: #f6f7ff; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    function DimensionalityQuest() {
      const W = 960, H = 600;
      const canvasRef = useRef(null);

      // ----- data model -----
      // 5D vectors with labels
      const COLORS = ["#ef4444","#10b981","#3b82f6","#f59e0b","#8b5cf6","#ec4899","#14b8a6","#eab308"];
      const [level, setLevel] = useState("blobs"); // "blobs" | "moons"
      const [seed, setSeed] = useState(1);
      const [points, setPoints] = useState([]);
      const [kClasses, setKClasses] = useState(3);

      const [method, setMethod] = useState("manual"); // "manual" | "pca" | "rand" | "neighbor"
      const [wX, setWX] = useState([1,0,0,0,0]);
      const [wY, setWY] = useState([0,1,0,0,0]);

      const [kNN, setKNN] = useState(6);
      const [showEdges, setShowEdges] = useState(false);
      const [auto, setAuto] = useState(false);
      const [iter, setIter] = useState(0);

      const [score, setScore] = useState(0);
      const target = level === "blobs" ? 0.6 : 0.55;
      const [won, setWon] = useState(false);

      function rng(seed) { let s = seed >>> 0; return () => (s = (1664525*s + 1013904223) >>> 0, (s & 0xffffffff)/0x100000000); }

      // ----- datasets (5D) -----
      function genBlobs(n=240, k=3) {
        const r = rng(seed);
        const means = [
          [ 2.2,  0.5,  0.0, -1.5,  0.3],
          [-1.0,  2.0,  0.5,  0.8, -0.7],
          [ 0.2, -1.3,  1.7,  0.6,  1.2],
          [ 2.0,  1.2, -1.5,  0.0, -0.3],
          [-1.8, -0.6,  1.0, -1.2,  0.9],
        ];
        const pts=[];
        for (let i=0;i<n;i++){
          const c = i % k;
          const m = means[c];
          const v = m.map(mu => mu + (r()-0.5)*0.9);
          pts.push({ v, label:c });
        }
        return pts;
      }

      function genMoons(n=240) {
        const r = rng(seed); const pts=[];
        for (let i=0;i<n/2;i++){
          const t = Math.PI * (i/(n/2));
          const base = [
            2.0*Math.cos(t),
            1.2*Math.sin(t),
            0.6*Math.cos(2*t),
            0.6*Math.sin(2*t),
            0.3*Math.cos(3*t),
          ];
          const v = base.map((b,j)=> b + (r()-0.5)*0.25 * (j<2?1.0:0.7));
          pts.push({ v, label:0 });
        }
        for (let i=0;i<n/2;i++){
          const t = Math.PI * (i/(n/2));
          const base = [
            2.0*Math.cos(t) + 1.8,
            -1.2*Math.sin(t) + 0.5,
            0.6*Math.cos(2*t+0.6),
            0.6*Math.sin(2*t+0.6),
            0.3*Math.cos(3*t+0.2),
          ];
          const v = base.map((b,j)=> b + (r()-0.5)*0.25 * (j<2?1.0:0.7));
          pts.push({ v, label:1 });
        }
        return pts;
      }

      useEffect(()=>{
        if (level==="blobs") { const k=3; setKClasses(k); setPoints(genBlobs(240,k)); }
        else { const k=2; setKClasses(k); setPoints(genMoons(240)); }
        setWon(false); setIter(0); setAuto(false);
      },[level, seed]);

      // ----- vector helpers -----
      const dot = (a,b)=> a.reduce((s,ai,i)=> s+ai*b[i], 0);
      const sub = (a,b)=> a.map((x,i)=> x-b[i]);
      const norm = v => Math.sqrt(dot(v,v));
      function center(X){
        const d=X[0].length; const mu=Array(d).fill(0);
        X.forEach(v=> v.forEach((val,j)=> mu[j]+=val));
        for(let j=0;j<d;j++) mu[j]/=X.length;
        return { X0: X.map(v=> sub(v,mu)), mu };
      }

      // ----- PCA via power iteration (top-2) -----
      function powerIterTop2(X){
        const d=X[0].length; const { X0 } = center(X);
        function covAx(x){
          const n=X0.length; const tmp=new Array(n);
          for (let i=0;i<n;i++) tmp[i] = dot(X0[i], x);
          const y = Array(d).fill(0);
          for (let j=0;j<d;j++){
            let s=0; for (let i=0;i<n;i++) s += X0[i][j]*tmp[i];
            y[j]=s/n;
          }
          return y;
        }
        function topVec(defl){
          let x = Array(d).fill(0).map(()=> Math.random()*2-1);
          for (let it=0; it<40; it++){
            let y = covAx(x);
            if (defl) {
              const qt = dot(defl.vec, x);
              for (let i=0;i<d;i++) y[i] -= defl.vec[i] * qt * defl.val;
            }
            const n = Math.max(1e-9, norm(y));
            x = y.map(v=> v/n);
          }
          const y = covAx(x); const val = dot(x,y);
          return { vec:x, val };
        }
        const q1 = topVec(); const q2 = topVec({ vec:q1.vec, val:q1.val });
        return [q1.vec, q2.vec];
      }

      function projectLinear(X, B){ // B=[b1,b2]
        const { X0 } = center(X);
        const n1=Math.max(1e-9, norm(B[0])), n2=Math.max(1e-9, norm(B[1]));
        const u1=B[0].map(x=> x/n1), u2=B[1].map(x=> x/n2);
        return X0.map(v=> ({ x: dot(v,u1), y: dot(v,u2) }));
      }

      function randomBasis(d=5){
        const r = rng(seed+123);
        function randVec(){ const v=Array(d).fill(0).map(()=> r()*2-1); const n=norm(v); return v.map(x=> x/n); }
        const a=randVec(); let b=randVec();
        const proj=dot(a,b); b=b.map((x,i)=> x - a[i]*proj); const nb=norm(b); b=b.map(x=> x/nb);
        return [a,b];
      }

      // neighbor graph + spring layout
      function knnGraph(X,k=6){
        const n=X.length; const adj=Array.from({length:n}, ()=>[]);
        for(let i=0;i<n;i++){
          const ds=[];
          for(let j=0;j<n;j++){ if(i===j) continue;
            let s=0; for(let t=0;t<X[i].length;t++){ const u=X[i][t]-X[j][t]; s+=u*u; }
            ds.push({j,d:Math.sqrt(s)});
          }
          ds.sort((p,q)=> p.d-q.d);
          adj[i]=ds.slice(0, k).map(e=> e.j);
        }
        return adj;
      }
      function neighborLayoutStep(pos, X, adj){
        const n=pos.length; const next = pos.map(p=> ({...p}));
        const kStiff=0.03, rest=0.7, repel=0.001;
        for(let i=0;i<n;i++){
          const pi=pos[i];
          for(const j of adj[i]){ if(j<=i) continue;
            const pj=pos[j]; const dx=pj.x-pi.x, dy=pj.y-pi.y;
            const dist=Math.hypot(dx,dy)+1e-6; const f=kStiff*(dist-rest);
            const fx=f*dx/dist, fy=f*dy/dist;
            next[i].x+=fx; next[i].y+=fy; next[j].x-=fx; next[j].y-=fy;
          }
        }
        for(let i=0;i<n;i++){
          for(let j=i+1;j<n;j++){
            const dx=next[j].x-next[i].x, dy=next[j].y-next[i].y;
            const d2=dx*dx+dy*dy+1e-6; const f=repel/d2; const fx=f*dx, fy=f*dy;
            next[i].x-=fx; next[i].y-=fy; next[j].x+=fx; next[j].y+=fy;
          }
        }
        return next;
      }

      // compute projection (except neighbor live positions)
      const projected = useMemo(()=>{
        if (points.length===0) return [];
        const X = points.map(p=> p.v);
        if (method==="manual") return projectLinear(X, [wX,wY]);
        if (method==="pca")    return projectLinear(X, powerIterTop2(X));
        if (method==="rand")   return projectLinear(X, randomBasis(5));
        // neighbor init = PCA
        return projectLinear(X, powerIterTop2(X));
      }, [points, method, wX, wY, seed]);

      // neighbor map state
      const [nmPos, setNmPos] = useState([]);
      const [nmAdj, setNmAdj] = useState([]);
      useEffect(()=>{
        if (method!=="neighbor") return;
        const X = points.map(p=> p.v);
        const init = projectLinear(X, powerIterTop2(X));
        setNmPos(init.map(p=> ({...p})));
        setNmAdj(knnGraph(X, kNN));
        setIter(0);
      }, [method, points, kNN]);

      useEffect(()=>{
        if (!auto || method!=="neighbor") return;
        const id = setInterval(()=>{
          setNmPos(prev=> neighborLayoutStep(prev, points.map(p=>p.v), nmAdj));
          setIter(n=> n+1);
        }, 40);
        return ()=> clearInterval(id);
      }, [auto, method, nmAdj, points]);

      // score
      const currScore = useMemo(()=>{
        const XY = (method==="neighbor" && nmPos.length===points.length) ? nmPos : projected;
        if (!XY.length) return 0;
        const k = kClasses;
        const groups = Array.from({length:k}, ()=>({sumX:0,sumY:0,n:0, idxs:[]}));
        for (let i=0;i<points.length;i++){
          const c=points[i].label; const p=XY[i];
          if (groups[c]) { groups[c].sumX+=p.x; groups[c].sumY+=p.y; groups[c].n++; groups[c].idxs.push(i); }
        }
        const mu={x:0,y:0};
        groups.forEach(g=> { mu.x+=g.sumX; mu.y+=g.sumY; });
        mu.x/=points.length; mu.y/=points.length;
        let SB=0, SW=0;
        for(let c=0;c<k;c++) if (groups[c] && groups[c].n>0){
          const mx=groups[c].sumX/groups[c].n, my=groups[c].sumY/groups[c].n;
          const dx=mx-mu.x, dy=my-mu.y; SB += dx*dx+dy*dy;
          groups[c].idxs.forEach(ii=>{
            const p=XY[ii]; const ux=p.x-mx, uy=p.y-my; SW += ux*ux+uy*uy;
          });
        }
        const s = SB/(SW+1e-6);
        return Math.max(0, Math.min(1, s));
      }, [projected, nmPos, method, points, kClasses]);

      useEffect(()=>{ setScore(currScore); setWon(currScore>=target); }, [currScore, target]);

      // draw
      useEffect(()=>{
        const canvas = canvasRef.current; const ctx = canvas.getContext("2d");
        ctx.clearRect(0,0,W,H);
        const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,"#f8fafc"); g.addColorStop(1,"#eef2ff");
        ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
        ctx.strokeStyle="#e5e7eb"; ctx.lineWidth=1;
        for(let x=40;x<W;x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
        for(let y=40;y<H;y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
        const XY = (method==="neighbor" && nmPos.length===points.length) ? nmPos : projected;
        if (XY.length){
          let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
          XY.forEach(p=> { if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; });
          const pad=30; const sx=(W-2*pad)/Math.max(1e-6,maxX-minX); const sy=(H-2*pad)/Math.max(1e-6,maxY-minY);
          const S=Math.min(sx,sy); const tx=(W - S*(maxX+minX))/2; const ty=(H - S*(maxY+minY))/2;

          if (method==="neighbor" && showEdges && nmAdj.length===points.length){
            ctx.strokeStyle="#94a3b8"; ctx.globalAlpha=0.4; ctx.lineWidth=1;
            for(let i=0;i<nmAdj.length;i++){
              for(const j of nmAdj[i]) if (j>i){
                const a=XY[i], b=XY[j];
                ctx.beginPath(); ctx.moveTo(tx+S*a.x, ty+S*a.y); ctx.lineTo(tx+S*b.x, ty+S*b.y); ctx.stroke();
              }
            }
            ctx.globalAlpha=1;
          }
          for(let i=0;i<points.length;i++){
            const p=XY[i]; const c=COLORS[points[i].label % COLORS.length];
            ctx.beginPath(); ctx.arc(tx+S*p.x, ty+S*p.y, 6, 0, Math.PI*2); ctx.fillStyle=c; ctx.globalAlpha=0.95; ctx.fill();
            ctx.globalAlpha=0.9; ctx.strokeStyle="#fff"; ctx.lineWidth=1; ctx.stroke(); ctx.globalAlpha=1;
          }
          if (won) {
            for(let k=0;k<120;k++){
              const x=Math.random()*W, y=Math.random()*H, r=2+Math.random()*3;
              ctx.fillStyle = COLORS[k % COLORS.length]; ctx.globalAlpha=0.35;
              ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
            }
          }
        }
        ctx.fillStyle="#111827"; ctx.globalAlpha=0.95; ctx.fillRect(0,0,W,36); ctx.globalAlpha=1;
        ctx.fillStyle="#fff"; ctx.font="600 16px ui-sans-serif, system-ui";
        const methodName = method==="manual"?"Manual Axes":method==="pca"?"PCA-2D":method==="rand"?"Random Projection":"Neighbor Map";
        ctx.fillText(`Dimensionality Quest — ${methodName}  |  Score: ${score.toFixed(2)} (goal ${target.toFixed(2)})`, 12, 24);
      }, [points, projected, nmPos, nmAdj, method, showEdges, score, target, won]);

      // click add/remove
      useEffect(()=>{
        const canvas = canvasRef.current;
        const rel = e => {
          const b = canvas.getBoundingClientRect();
          return { x:(e.clientX-b.left)*(W/b.width), y:(e.clientY-b.top)*(H/b.height) };
        };
        const onClick = e => {
          const { x,y } = rel(e);
          const XY = (method==="neighbor" && nmPos.length===points.length) ? nmPos : projected;
          if (!XY.length) return;
          let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
          XY.forEach(p=> { if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; });
          const pad=30; const sx=(W-2*pad)/Math.max(1e-6,maxX-minX); const sy=(H-2*pad)/Math.max(1e-6,maxY-minY);
          const S=Math.min(sx,sy); const tx=(W - S*(maxX+minX))/2; const ty=(H - S*(maxY+minY))/2;
          const px=(x - tx)/S, py=(y - ty)/S;

          if (e.shiftKey) {
            let bi=-1, bd=Infinity; for (let i=0;i<XY.length;i++){ const u=XY[i]; const d=(u.x-px)**2+(u.y-py)**2; if(d<bd){bd=d;bi=i;} }
            if (bi>=0) setPoints(prev=> prev.filter((_,i)=> i!==bi));
            return;
          }
          let bi=-1, bd=Infinity; for (let i=0;i<XY.length;i++){ const u=XY[i]; const d=(u.x-px)**2+(u.y-py)**2; if(d<bd){bd=d;bi=i;} }
          if (bi>=0) {
            const base = points[bi]; const r = rng(seed+points.length*13);
            const v = base.v.map(val=> val + (r()-0.5)*0.3);
            setPoints(prev=> [...prev, { v, label: base.label }]);
            if (method==="neighbor") setNmPos(prev=> [...prev, {x:px,y:py}]);
          }
        };
        canvas.addEventListener("click", onClick);
        return ()=> canvas.removeEventListener("click", onClick);
      }, [points, projected, nmPos, method, seed]);

      function resetManual(){ setWX([1,0,0,0,0]); setWY([0,1,0,0,0]); setWon(false); }
      function shuffle(){ setSeed(s=> s+1); }
      function stepNeighbor(){ if (method!=="neighbor") return; setNmPos(prev=> neighborLayoutStep(prev, points.map(p=>p.v), nmAdj)); setIter(n=> n+1); }

      const spreads = useMemo(()=>{
        if (!points.length) return new Array(5).fill(0);
        const X = points.map(p=> p.v); const d=5; const mu=Array(d).fill(0);
        X.forEach(v=> v.forEach((val,j)=> mu[j]+=val)); for (let j=0;j<d;j++) mu[j]/=X.length;
        const s2=Array(d).fill(0); X.forEach(v=> v.forEach((val,j)=> { const u=val-mu[j]; s2[j]+=u*u; }));
        return s2.map(x=> Math.sqrt(x/Math.max(1,X.length-1)));
      }, [points, seed]);

      return (
        <div className="w-full min-h-[100vh] bg-gradient-to-b from-indigo-50 to-white p-4 flex flex-col items-center gap-4">
          <h1 className="text-2xl font-semibold tracking-tight">Dimensionality Quest</h1>
          <p className="text-gray-700 -mt-2">Project 5D data down to 2D and separate the colors! (That’s dimensionality reduction.)</p>

          <div className="flex flex-wrap items-center gap-2">
            <div className="inline-flex rounded-2xl bg-gray-100 p-1">
              {["blobs","moons"].map(l => (
                <button key={l} onClick={()=> setLevel(l)} className={`px-3 py-1.5 rounded-xl ${level===l?"bg-white shadow font-medium":"text-gray-600"}`}>
                  {l==="blobs"?"Level 1: Blobs":"Level 2: Twisty Moons"}
                </button>
              ))}
            </div>
            <button className="px-3 py-1.5 rounded-xl bg-gray-900 text-white" onClick={shuffle}>Shuffle dataset</button>
            <div className="h-6 w-px bg-gray-300" />
            <div className="inline-flex rounded-2xl bg-gray-100 p-1">
              {["manual","pca","rand","neighbor"].map(m => (
                <button key={m} onClick={()=> { setMethod(m); setAuto(false); setWon(false); }} className={`px-3 py-1.5 rounded-xl ${method===m?"bg-white shadow font-medium":"text-gray-600"}`}>
                  {m==="manual"?"Manual Axes": m==="pca"?"PCA-2D": m==="rand"?"Random":"Neighbor Map"}
                </button>
              ))}
            </div>
            {method==="neighbor" && (
              <>
                <label className="flex items-center gap-2 ml-2 text-sm">k-NN
                  <input type="range" min={2} max={16} value={kNN} onChange={e=> setKNN(parseInt(e.target.value))} />
                  <span className="w-8 text-center font-medium">{kNN}</span>
                </label>
                <button className={`px-3 py-1.5 rounded-xl ${auto?"bg-rose-600":"bg-emerald-600"} text-white`} onClick={()=> setAuto(a=> !a)}>{auto?"Stop":"Auto"}</button>
                <button className="px-3 py-1.5 rounded-xl bg-indigo-600 text-white" onClick={stepNeighbor}>Step</button>
                <label className="flex items-center gap-2 ml-2 text-sm">
                  <input type="checkbox" checked={showEdges} onChange={e=> setShowEdges(e.target.checked)} /> Show neighbor edges
                </label>
                <span className="text-sm text-gray-600 ml-2">Iterations: <b>{iter}</b></span>
              </>
            )}
          </div>

          <div className="w-full max-w-[1000px] rounded-2xl shadow-lg bg-white p-3">
            <canvas ref={canvasRef} width={W} height={H} className="w-full rounded-xl border border-gray-200" />
          </div>

          {method==="manual" && (
            <div className="w-full max-w-[1000px] grid md:grid-cols-2 gap-4">
              <Card title="Choose your own axes (weights for 5D → X,Y)">
                <div className="space-y-2 text-sm">
                  {[0,1,2,3,4].map(j => (
                    <div key={j} className="flex items-center gap-3">
                      <span className="w-6 text-gray-600">d{j+1}</span>
                      <input type="range" min={-1} max={1} step={0.01} value={wX[j]}
                        onChange={e=> setWX(prev=> prev.map((v,i)=> i===j? parseFloat(e.target.value): v))} className="flex-1" />
                      <span className="w-10 text-right">{wX[j].toFixed(2)}</span>
                      <span className="w-4 text-center text-gray-400">→</span>
                      <input type="range" min={-1} max={1} step={0.01} value={wY[j]}
                        onChange={e=> setWY(prev=> prev.map((v,i)=> i===j? parseFloat(e.target.value): v))} className="flex-1" />
                      <span className="w-10 text-right">{wY[j].toFixed(2)}</span>
                    </div>
                  ))}
                  <div className="flex gap-2">
                    <button className="px-3 py-1.5 rounded-xl bg-gray-800 text-white" onClick={()=>{ setWX([1,0,0,0,0]); setWY([0,1,0,0,0]); setWon(false); }}>Reset</button>
                    <button className="px-3 py-1.5 rounded-xl bg-emerald-600 text-white" onClick={()=> setMethod("pca")}>Try PCA for a hint</button>
                  </div>
                </div>
              </Card>
              <Card title="Which dimensions matter? (spread per feature)">
                <div className="space-y-2">
                  {[0,1,2,3,4].map(j => (
                    <div key={j} className="flex items-center gap-2">
                      <span className="w-8">d{j+1}</span>
                      <div className="flex-1 bg-gray-100 rounded-full h-2 overflow-hidden">
                        <div className="bg-indigo-500 h-2" style={{ width: `${Math.min(100, spreads[j]*35)}%` }} />
                      </div>
                      <span className="w-12 text-right text-gray-600">{spreads[j].toFixed(2)}</span>
                    </div>
                  ))}
                  <div className="text-gray-600 text-sm">Tip: PCA finds the directions with big spread automatically.</div>
                </div>
              </Card>
            </div>
          )}

          <div className="grid md:grid-cols-2 gap-4 max-w-[1000px]">
            <Card title="Goal">
              <div className="text-gray-700">
                Reach a <b>score ≥ {target.toFixed(2)}</b> by separating colors in 2D.
                Score measures how far the color centers are compared to how wiggly each group is.
              </div>
              <div className="mt-2 text-sm text-gray-600">
                Click to add points • Shift+Click to remove. In Neighbor Map, let it iterate or press Step to untangle twisty shapes.
              </div>
            </Card>
            <Card title="Mini challenges">
              <ol className="list-decimal pl-5 space-y-2 text-gray-700 text-sm">
                <li>Level 1: Use <b>PCA</b>. Does it beat random? Try Manual to copy PCA’s idea.</li>
                <li>Level 1: Make X use mostly <code>d1</code> & <code>d2</code>, and Y use <code>d3</code> — can you hit the goal?</li>
                <li>Level 2: Start with PCA, then switch to <b>Neighbor Map</b>. Turn on edges and watch clusters separate.</li>
                <li>Click to add your own “rogue” points. Which method is robust?</li>
              </ol>
            </Card>
          </div>

          <div className="text-xs text-gray-500">No build tools required — runs entirely in the browser via CDNs.</div>
        </div>
      );
    }

    function Card({ title, children }) {
      return (
        <div className="bg-white rounded-2xl shadow p-4">
          <div className="font-semibold mb-2">{title}</div>
          <div>{children}</div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<DimensionalityQuest />);
  </script>
</body>
</html>
